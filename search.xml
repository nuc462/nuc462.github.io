<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0～n-1中缺失的数字</title>
    <url>/2022/05/22/0%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/22/0%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/image-20220522212717368.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、普通遍历：</strong></p>
<ul>
<li><p><strong>思路一：</strong>正常是后一个比前一个大一，找不正常的</p>
<ul>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历求解，思路是正常是后一个比前一个大一，找不正常的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == nums.length -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">return</span> nums[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i != nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i+<span class="number">1</span>] == nums[i] + <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果为空返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>思路二：</strong>正常是数组下标位置对应数组的值，找不正常的</p>
<ul>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]!=i) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是前面是连续的，后面没有东西，则得返回长度;</span></span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n)</li>
<li><strong>空间复杂度：</strong>O(1)</li>
</ul>
</li>
</ul>
<p><strong>2、二分法实现</strong></p>
<ul>
<li><p><strong>思路：</strong>划分为俩个组，一个是正常的组，一个比自身位置大于1的组，最后left&gt;right,输出。</p>
<ul>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分法实现，思路就是划分为俩个组，一个是正常的组，一个比自身位置大于1的组，最后left&gt;right,输出</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; mid) &#123;</span><br><span class="line">                right = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(logn)</li>
<li><strong>空间复杂度：</strong>O(1)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>查找算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中Collection和Collections的区别</title>
    <url>/2022/05/25/Java%E4%B8%ADCollection%E5%92%8CCollections%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<p><strong>根本区别</strong></p>
<p><strong>1.Collection</strong>是一个<strong>集合接口</strong>。它提供了对集合对象进行基本操作的通用接口方法。	</p>
<p>​	Collection接口在Java类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供最大化的统一操作方式。<br>​	以下接口实现了Collection接口：<br>​		map、set、list、vector</p>
<p><em><img src="/2022/05/25/Java%E4%B8%ADCollection%E5%92%8CCollections%E7%9A%84%E5%8C%BA%E5%88%AB/image-20220525075553014.png" class title="examplename"></em></p>
<p><strong>2.Collections</strong>是一个<strong>包装类</strong>。它包含各种有关集合操作的<strong>静态多态方法</strong>。此类<strong>不能实例化</strong>，就像一个工具类，服务于Java的Collection框架。<br><strong>（1）排序(Sort)</strong><br>        使用sort方法可以根据元素的自然顺序对指定列表按升序进行排列。列表中所有元素都必须实现Comparable接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionExp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> array[] = &#123;<span class="number">112</span>, <span class="number">111</span>, <span class="number">23</span>, <span class="number">456</span>, <span class="number">231</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            list.add(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(list);<span class="comment">//排序</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：[23, 111, 112, 231, 456]<br><strong>（2）反转(Reverse)</strong><br>        使用Reverse方法可以根据元素的自然顺序，对指定列表按降序进行排序。</p>
<p>Collections.reverse(list);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionExp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> array[] = &#123;<span class="number">112</span>, <span class="number">111</span>, <span class="number">23</span>, <span class="number">456</span>, <span class="number">231</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            list.add(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(list);<span class="comment">//反转</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：[231, 456, 23, 111, 112]<br><strong>（3）替换所有元素（Fill）</strong><br>        使用指定元素替换指定列表中的所有元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionExp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> array[] = &#123;<span class="number">112</span>, <span class="number">111</span>, <span class="number">23</span>, <span class="number">456</span>, <span class="number">231</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            list.add(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.fill(list,-<span class="number">1</span>);<span class="comment">//替换</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：[-1, -1, -1, -1, -1]<br><strong>（4）拷贝（copy）</strong><br>        用两个参数，一个目标 List 和一个源 List, 将源的元素拷贝到目标，并覆盖它的内容。目标 List 至少与源一样长。如果它更长，则在目标 List 中的剩余元素不受影响。</p>
<p>Collections.copy(list,li): 前面一个参数是目标列表 ,后一个是源列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionExp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> array[] = &#123;<span class="number">112</span>, <span class="number">111</span>, <span class="number">23</span>, <span class="number">456</span>, <span class="number">231</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            list.add(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.fill(list,-<span class="number">1</span>);<span class="comment">//替换</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码时报如下异常</p>
<p><em><img src="/2022/05/25/Java%E4%B8%ADCollection%E5%92%8CCollections%E7%9A%84%E5%8C%BA%E5%88%AB/image-20220525085321951.png" class title="examplename"></em></p>
<p>解决办法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionExp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//源列表</span></span><br><span class="line">        <span class="type">int</span> array[] = &#123;<span class="number">112</span>, <span class="number">111</span>, <span class="number">23</span>, <span class="number">456</span>, <span class="number">231</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            list.add(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[list.size()]));<span class="comment">//目标列表</span></span><br><span class="line">        Collections.copy(list1,list);<span class="comment">//替换</span></span><br><span class="line">        System.out.println(list1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：[112, 111, 23, 456, 231]<br><strong>（5）返回Collections中最小元素(min)</strong><br>        根据指定比较器产生的顺序，返回给定 collection 的最小元素。collection 中的所有元素都必须是通过指定比较器可相互比较的。<br>Collections.min(list)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionExp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//源列表</span></span><br><span class="line">        <span class="type">int</span> array[] = &#123;<span class="number">112</span>, <span class="number">111</span>, <span class="number">23</span>, <span class="number">456</span>, <span class="number">231</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            list.add(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Collections.min(list);<span class="comment">//替换</span></span><br><span class="line">        System.out.println(min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：23<br><strong>（6）返回Collections中最小元素(max)</strong><br>根据指定比较器产生的顺序，返回给定 collection 的最大元素。collection 中的所有元素都必须是通过指定比较器可相互比较的。<br>Collections.max(list)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionExp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//源列表</span></span><br><span class="line">        <span class="type">int</span> array[] = &#123;<span class="number">112</span>, <span class="number">111</span>, <span class="number">23</span>, <span class="number">456</span>, <span class="number">231</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            list.add(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Collections.max(list);<span class="comment">//替换</span></span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：456<br>————————————————<br>版权声明：本文为CSDN博主「行万里路，读万卷书」的原创文章<br>原文链接：<a href="https://blog.csdn.net/qq_40742428/article/details/100170033">https://blog.csdn.net/qq_40742428/article/details/100170033</a></p>
]]></content>
      <categories>
        <category>基础</category>
        <category>集合</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>java.util.concurrentmodificationexception异常原因和解决方法</title>
    <url>/2022/04/24/java.util.concurrentmodificationexception%E5%BC%82%E5%B8%B8%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>简单地说下原因，在我那个项目的代码中，遍历的方式是增强 for 循环，在底层使用的也是迭代器。</p>
<span id="more"></span>

<p>也就是说，是用Itr去遍历的，这个Itr是ArrayList实现的一个遍历接口、内部类。</p>
<p>但是我在删除的时候是通过ArrayList的remove方法去操作的，不是Itr内部的那个删除方法去操作的。</p>
<p>那么问题就来了：</p>
<p>ArrayList的remove方法修改的变量是继承自AbstractList的变量modCount；而Itr的remove方法修改的是自身的变量expectedModCount。这两个变量的作用都是记录修改次数的。</p>
<p>所以，在用ArrayList的remove方法进行删除操作以后，Itr里面的expectedModCount会与ArrayList的modCount进行比较，二者不相等，所以会抛错。</p>
<p><img src="https://img-blog.csdnimg.cn/111081d940d648c3b2156c4cb037dd6b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeTR1bmc=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="img"></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>解决的方法是改成索引遍历,但是需要在删除之后保证索引的正常:</p>
]]></content>
      <categories>
        <category>异常</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql笔记</title>
    <url>/2022/05/26/mysql%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h1 id="true、false、unknown-和-null"><a href="#true、false、unknown-和-null" class="headerlink" title="true、false、unknown 和 null"></a>true、false、unknown 和 null</h1><p>​		SQL 的保留字中，有很多都被归为谓词一类。例如，“&#x3D;、&lt;、&gt;”等比较谓词，以及 BETWEEN、LIKE、IN、IS NULL 等。</p>
<p>​		谓词是一种特殊的函数，返回值是<a href="https://so.csdn.net/so/search?q=%E7%9C%9F%E5%80%BC&spm=1001.2101.3001.7020">真值</a>。前面提到的每个谓词，返回值都是 <strong>true</strong>、<strong>false</strong> 或者 <strong>unknown</strong>（一般的谓词逻辑里没有<strong>unknown</strong>，但是 SQL 采用的是三值逻辑，因此具有三种真值）。</p>
<p>​		另外，注意：任何与 <code>NULL</code> 值进行的比较都会与第三种值 UNKNOWN 做比较。这个“任何值”包括 <code>NULL</code> 本身。要想 <strong>和 null 比较</strong> 只能用 <code>is null</code>或者 <code>is not null</code>，这样才会返回true或者false。另外永远记住一点，<strong>null和&lt;,&gt;,&#x3D;,&lt;&gt;这些放在一起结果永远是unknown</strong>，比如如 2&#x3D;null，结果肯定是unknown，而<strong>unknown在三值逻辑中不是true也不是false</strong>，在写where子句的筛选条件时尤其要注意。</p>
<p><strong>请务必牢记</strong>：</p>
<ul>
<li>and运算，只要有一边是unknown，另一边是false，那结果就是false，其它情况下，只要任意一边有unknown，结果就是unknown。</li>
<li>or运算，只要一边是unknown，那么结果永远就是unknown</li>
<li>not unknown 的结果是 unknown</li>
</ul>
<h1 id="SQL语句的内连接，外连接，左连接，右连接，全连接详解例子"><a href="#SQL语句的内连接，外连接，左连接，右连接，全连接详解例子" class="headerlink" title="SQL语句的内连接，外连接，左连接，右连接，全连接详解例子"></a>SQL语句的内连接，外连接，左连接，右连接，全连接详解例子</h1><p>具体请看：<a href="https://blog.csdn.net/qq_45064695/article/details/118997954">https://blog.csdn.net/qq_45064695/article/details/118997954</a></p>
<p><em><img src="/2022/05/26/mysql%E7%AC%94%E8%AE%B0/image-20220529173210401.png" class title="examplename"></em></p>
]]></content>
      <categories>
        <category>基础</category>
        <category>mysql</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>两个链表的第一个公共节点</title>
    <url>/2022/05/29/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/29/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/image-20220529163001950.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、哈希表法</strong></p>
<ul>
<li><p><strong>解题思想：</strong>先把链表<em>headA</em>都放在set集合中，然后循环链表 <em>headB</em>比较 <em>headB</em>和<em>headA</em>的&#x3D;&#x3D;指针&#x3D;&#x3D;是否有相同，相同则，说明找到了第一个公共节点，返回该指针。否则没无公共节点，返回null。</p>
</li>
<li><p><strong>复杂度分析</strong></p>
<ul>
<li><p>**时间复杂度：O(m+n)**，其中 m 和 n 是分别是链表 headA 和 headB 的长度。需要遍历两个链表各一次。</p>
</li>
<li><p>**空间复杂度：O(m)**，其中 m 是链表 headA 的长度。需要使用哈希集合存储链表 headA 中的全部节点。</p>
</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哈希表法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        Set&lt;ListNode&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;ListNode&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">            visited.add(temp);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = headB;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果set集合包含temp指针，则headA和headB链表有相同的指针</span></span><br><span class="line">            <span class="keyword">if</span> (visited.contains(temp)) &#123;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、双指针</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li><em></em></li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><p>**时间复杂度：O(m+n)**，其中 m 和 n 是分别是链表 headA 和 headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。</p>
</li>
<li><p>**空间复杂度：O(1)**。</p>
</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">b</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="keyword">while</span>(a != b) &#123;</span><br><span class="line">            a = a != <span class="literal">null</span> ? a.next : headB;</span><br><span class="line">            b = b != <span class="literal">null</span> ? b.next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>双指针</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>No primary or default constructor found for interface java.util.List原因和解决方法</title>
    <url>/2022/04/24/No%20primary%20or%20default%20constructor%20found%20for%20interface%20java.util.List%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>是list是接口，没有<strong>构造函数</strong></p>
<span id="more"></span>

<p><strong>解决方法：</strong></p>
<ul>
<li>换成ArrayList就可以，</li>
<li>将List转为Json字符串（JSON.toJSONString(list)），或者加入@RequestBody注解</li>
<li>目标对象不匹配，用＠RequestParam让他强制匹配</li>
</ul>
]]></content>
      <categories>
        <category>异常</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的镜像</title>
    <url>/2022/05/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/image-20220525171630651.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、辅助队列（或栈）</strong></p>
<ul>
<li><p><strong>解题思路：</strong>利用队列（或栈）遍历树的所有节点 poll，并交换每个 poll 的左 &#x2F; 右子节点。</p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> 其中 N 为二叉树的节点数量，建立二叉树镜像需要遍历树的所有节点，占用 O(N) 时间。</li>
<li><strong>空间复杂度 O(N) ：</strong> 如下图所示，最差情况下，队列 最多同时存储 (N+1)&#x2F; 2个节点，占用 O(N) 额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue  = <span class="keyword">new</span> <span class="title class_">LinkedList</span>() &#123;&#123; add(root); &#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (poll.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(poll.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (poll.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(poll.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将左右子节点的位置交换</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> poll.left;</span><br><span class="line">                poll.left = poll.right;</span><br><span class="line">                poll.right = tmp;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、递归法</strong></p>
<ul>
<li><p><strong>解题思路：</strong>根据二叉树镜像的定义，考虑递归遍历（dfs）二叉树，交换每个节点的左 &#x2F; 右子节点，即可生成二叉树的镜像。</p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N)</strong> ： 其中 N 为二叉树的节点数量，建立二叉树镜像需要遍历树的所有节点，占用 O(N)时间。</li>
<li><strong>空间复杂度 O(N) ：</strong> 最差情况下（当二叉树退化为链表），递归时系统需使用 O(N) 大小的栈空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过递归交换子结点的位置</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = mirrorTree(root.right);</span><br><span class="line">        root.right = mirrorTree(tmp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>搜索与回溯</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二维数组中的查找</title>
    <url>/2022/05/23/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/23/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/image-20220523112001365.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、二分查找</strong></p>
<ul>
<li><p><strong>解题思路：</strong>将每一行进行二分查找。</p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度O(mlogn)：</strong>m为行数，n为列数</li>
<li><strong>空间复杂度O(1)</strong></li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分查找时间复杂度O(mlogn)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取行数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="comment">// 获取列数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; col; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">Left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 一行的长度matrix[0].length(有几列)</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">Right</span> <span class="operator">=</span> row - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (Left &lt; Right ) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> Left + (Right - Left) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (target &gt; matrix[i][mid]) &#123;</span><br><span class="line">                    Left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (target &lt; matrix[i][mid]) &#123;</span><br><span class="line">                    Right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">if</span> (Left == Right) &#123;</span><br><span class="line">                System.out.println(matrix[i][Right]);</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][Right] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、标志数法</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li><p>“根节点” 对应的是矩阵的 “左下角” 和 “右上角” 元素，本文称之为 标志数 ，以 matrix 中的 左下角元素 为标志数 flag ，则有:	</p>
<ul>
<li>若 flag &gt; target ，则 target 一定在 flag 所在 行的上方 ，即 flag 所在行可被消去。</li>
<li>若 flag &lt; target ，则 target 一定在 flag 所在 列的右方 ，即 flag 所在列可被消去。</li>
</ul>
</li>
<li><p><em><img src="/2022/05/23/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/image-20220523112822109.png" class title="examplename"></em></p>
</li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li>**时间复杂度O(m+n)**，m为行数，n为列数</li>
<li><strong>空间复杂度O(1)</strong></li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标志数法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &gt; matrix[i][j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (target &lt; matrix[i][j]) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (target == matrix[i][j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>查找算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>从上到下打印二叉树</title>
    <url>/2022/05/24/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/24/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220524154009085.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><ul>
<li><p><strong>解题思路：</strong>判断当队列不为空时，进行将队列中树指针所指向的值有数值的值放入list集合，最后遍历list集合给数组并返回。</p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> N 为二叉树的节点数量，即 BFS 需循环 N 次。</li>
<li><strong>空间复杂度 O(N) ：</strong> 最差情况下，即当树为平衡二叉树时，最多有 N&#x2F;2个树节点同时在 queue 中，使用 O(N)大小的额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">      TreeNode left;</span><br><span class="line">      TreeNode right;</span><br><span class="line">      TreeNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化队列，将树的头结点指针放到队列中，&#123;&#123; add(root); &#125;&#125;;是匿名内部方法，相当于queue.add(root);</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue  = <span class="keyword">new</span> <span class="title class_">LinkedList</span>() &#123;&#123; add(root); &#125;&#125;;</span><br><span class="line">        <span class="comment">// 初始化list集合</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当队列不为空时，进行将队列中树指针所指向的值有数值的值放入list集合</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 移除并返问队列头部的元素,给TreeNode类型，队列里的树的指针根据队列的特性，先进先出，实现广度优先遍历</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            System.out.println(node);</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            a[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>搜索与回溯</category>
        <category>广度优先搜索</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>从上到下打印二叉树II</title>
    <url>/2022/05/24/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91II/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/24/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91II/image-20220524171430529.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><ul>
<li><p><strong>解题思路：</strong>借助 <strong>队列</strong> 的先入先出特性。 将本层全部节点打印到一行，并将下一层全部节点加入队列，以此类推，即可分为多行打印。</p>
<ul>
<li>参考  <a herf="https://nuc462.github.io/2022/05/24/从上到下打印二叉树/">从上到下打印二叉树 - 轩辕&amp;小站</a>中加入一层循环，将上一次放入栈的所有结点都输出。</li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N)：</strong> N 为二叉树的节点数量，即 BFS 需循环 N 次。</li>
<li><strong>空间复杂度 O(N) ：</strong> 最差情况下，即当树为平衡二叉树时，最多有 N&#x2F;2 个树节点同时在 queue 中，使用 O(N) 大小的额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">      <span class="type">int</span> val;</span><br><span class="line">      TreeNode left;</span><br><span class="line">      TreeNode right;</span><br><span class="line">      TreeNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue  = <span class="keyword">new</span> <span class="title class_">LinkedList</span>() &#123;&#123; add(root); &#125;&#125;;</span><br><span class="line">        <span class="comment">// 初始化返回的list</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 这样避免了因为queue的值改变，queue.size()变化而报错的情况</span></span><br><span class="line">            <span class="comment">// 或者可以这样解决</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * int currentLevelSize = queue.size();</span></span><br><span class="line"><span class="comment">            * for (int i = 1; i &lt;= currentLevelSize; ++i)&#123;...&#125;</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                tmp.add(poll.val);</span><br><span class="line">                <span class="keyword">if</span> (poll.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(poll.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (poll.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(poll.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>搜索与回溯</category>
        <category>广度优先搜索</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>从不订购的客户</title>
    <url>/2022/05/29/%E4%BB%8E%E4%B8%8D%E8%AE%A2%E8%B4%AD%E7%9A%84%E5%AE%A2%E6%88%B7/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/29/%E4%BB%8E%E4%B8%8D%E8%AE%A2%E8%B4%AD%E7%9A%84%E5%AE%A2%E6%88%B7/image-20220529173504450.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、使用左连接</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li><em><img src="/2022/05/29/%E4%BB%8E%E4%B8%8D%E8%AE%A2%E8%B4%AD%E7%9A%84%E5%AE%A2%E6%88%B7/image-20220529173609126.png" class title="examplename"></em></li>
</ul>
</li>
<li><p><strong>sql语句：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.Name <span class="keyword">as</span> Customers</span><br><span class="line"><span class="keyword">from</span> Customers <span class="keyword">as</span> a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> Orders <span class="keyword">as</span> b </span><br><span class="line"><span class="keyword">on</span> a.Id <span class="operator">=</span> b.CustomerId</span><br><span class="line"><span class="keyword">where</span> b.CustomerId <span class="keyword">is</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、使用子查询和 <code>NOT IN</code> 子句</strong></p>
<ul>
<li><p><strong>sql语句：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.Name <span class="keyword">as</span> Customers</span><br><span class="line"><span class="keyword">from</span> Customers <span class="keyword">as</span> a</span><br><span class="line"><span class="keyword">where</span> a.id <span class="keyword">not</span> <span class="keyword">in</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> CustomerId <span class="keyword">from</span> Orders</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>基础</category>
        <category>mysql</category>
        <category>SQL入门</category>
        <category>选择</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>SQL入门</tag>
      </tags>
  </entry>
  <entry>
    <title>从上到下打印二叉树III</title>
    <url>/2022/05/25/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91III/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/25/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91III/image-20220525094821687.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、层序遍历 + 倒序</strong></p>
<ul>
<li><p><strong>解题思路：</strong>在参考：<a herf="https://nuc462.github.io/2022/05/24/从上到下打印二叉树II/">从上到下打印二叉树II - 轩辕&amp;小站</a>的基础上加入：当是偶数层是将list集合进行反转.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (list.size() % <span class="number">2</span> == <span class="number">1</span>) Collections.reverse(tmp);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> N 为二叉树的节点数量，即 BFS 需循环 N 次，占用 O(N) 。共完成 少于 N 个节点的倒序操作，占用 O(N)。</li>
<li><strong>空间复杂度 O(N)</strong> ： 最差情况下，即当树为满二叉树时，最多有 N&#x2F;2 个树节点同时在 queue 中，使用 O(N) 大小的额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 层序遍历 + 倒序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue  = <span class="keyword">new</span> <span class="title class_">LinkedList</span>() &#123;&#123; add(root); &#125;&#125;;</span><br><span class="line">        <span class="comment">// 初始化返回的list</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 这样避免了因为queue的值改变，queue.size()变化而报错的情况</span></span><br><span class="line">            <span class="comment">// 或者可以这样解决</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * int currentLevelSize = queue.size();</span></span><br><span class="line"><span class="comment">             * for (int i = 1; i &lt;= currentLevelSize; ++i)&#123;...&#125;</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                tmp.add(poll.val);</span><br><span class="line">                <span class="keyword">if</span> (poll.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(poll.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (poll.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(poll.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在II的基础上加入当是偶数层是将list集合进行反转</span></span><br><span class="line">            <span class="keyword">if</span> (list.size() % <span class="number">2</span> == <span class="number">1</span>) Collections.reverse(tmp);</span><br><span class="line">            list.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、层序遍历 + 双端队列(奇偶层逻辑未分离)</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li>利用双端队列的两端皆可添加元素的特性，设打印列表（双端队列）<code>tmp</code>，并规定：<ul>
<li>奇数层 则添加至 <code>tmp</code> <strong>尾部</strong> ，</li>
<li>偶数层 则添加至 <code>tmp</code> <strong>头部</strong> 。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> N 为二叉树的节点数量，即 BFS 需循环 N 次，占用 O(N) 。共完成 少于 N 个节点的倒序操作，占用 O(N)。</li>
<li><strong>空间复杂度 O(N)</strong> ： 最差情况下，即当树为满二叉树时，最多有 N&#x2F;2 个树节点同时在 queue 中，使用 O(N) 大小的额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 层序遍历 + 双端队列(奇偶层逻辑未分离)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>() &#123;&#123;</span><br><span class="line">            add(root);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        <span class="comment">// 初始化返回的list</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            LinkedList&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 奇数层，添加元素至队列尾部</span></span><br><span class="line">                <span class="keyword">if</span> (list.size() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    tmp.addLast(poll.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 偶数层，添加元素只队列头部</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tmp.addFirst(poll.val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (poll.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(poll.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (poll.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(poll.right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            list.add(tmp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3、层序遍历 + 双端队列（奇偶层逻辑分离）</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li>方法一代码简短、容易实现；但需要判断每个节点的所在层奇偶性，即冗余了 <em>N</em> 次判断。</li>
<li>通过将奇偶层逻辑拆分，可以消除冗余的判断。</li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> N 为二叉树的节点数量，即 BFS 需循环 N 次，占用 O(N) 。共完成 少于 N 个节点的倒序操作，占用 O(N)。</li>
<li><strong>空间复杂度 O(N)</strong> ： 最差情况下，即当树为满二叉树时，最多有 N&#x2F;2 个树节点同时在 <code>queue</code>或<code>deque</code> 中，使用 O(N) 大小的额外空间。</li>
</ul>
</li>
<li><p><code>queue</code><strong>实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 层序遍历 + 双端队列（奇偶层逻辑分离），使用Queue</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>() &#123;&#123;</span><br><span class="line">            add(root);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        <span class="comment">// 初始化返回的list</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 打印奇数层</span></span><br><span class="line">            LinkedList&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 每次往尾部加</span></span><br><span class="line">                tmp.addLast(poll.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (poll.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(poll.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (poll.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(poll.right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            list.add(tmp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(queue.isEmpty()) <span class="keyword">break</span>; <span class="comment">// 若为空则提前跳出</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印偶数层</span></span><br><span class="line">            tmp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 每次往头部加</span></span><br><span class="line">                tmp.addFirst(poll.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (poll.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(poll.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (poll.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(poll.right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            list.add(tmp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>deque</code> <strong>实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 层序遍历 + 双端队列（奇偶层逻辑分离），使用Deque</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) deque.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 打印奇数层</span></span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> deque.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">// 从左向右打印</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.removeFirst();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="comment">// 先左后右加入下层节点</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) deque.addLast(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) deque.addLast(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">            <span class="keyword">if</span>(deque.isEmpty()) <span class="keyword">break</span>; <span class="comment">// 若为空则提前跳出</span></span><br><span class="line">            <span class="comment">// 打印偶数层</span></span><br><span class="line">            tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> deque.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">// 从右向左打印</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.removeLast();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="comment">// 先右后左加入下层节点</span></span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) deque.addFirst(node.right);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) deque.addFirst(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>搜索与回溯</category>
        <category>广度优先搜索</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>从尾到头打印链表</title>
    <url>/2022/05/21/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/21/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/image-20220521104152321.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、方法一：使用辅助栈实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; stack = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!(head == <span class="literal">null</span>))&#123;</span><br><span class="line">            stack.push(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[stack.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">                a[i] = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：使用递归实现</strong>（从后往前将链表中的数据放入list里）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        recur(head);</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[tmp.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = tmp.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">recur</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        recur(head.next);</span><br><span class="line">        tmp.add(head.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表的节点</title>
    <url>/2022/05/29/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/29/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/image-20220529084329139.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、单指针</strong></p>
<p><strong>1.1 未设哨兵节点dummyHead</strong></p>
<ul>
<li><p><strong>解题思路：</strong>值相等时，如果是第一个节点，直接让head指向他的下一个；如果不是第一个节点，l.next &#x3D; l.next.next。</p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> N 为链表长度，删除操作平均需循环 N&#x2F;2 次，最差 N 次。</li>
<li><strong>空间复杂度 O(1)</strong></li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未设哨兵节点dummyHead</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteNode</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.val == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (l.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l.next.val == val) &#123;</span><br><span class="line">                l.next = l.next.next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l = l.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>1.2 设哨兵节点dummyHead</strong></p>
<ul>
<li><p><strong>解题思路：</strong>哨兵节点指向head，让节点l指向哨兵节点，值相等时，l.next &#x3D; l.next.next。</p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> N 为链表长度，删除操作平均需循环 N&#x2F;2 次，最差 N 次。</li>
<li><strong>空间复杂度 O(1)</strong></li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设哨兵节点dummyHead</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteNode</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设哨兵节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (l.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l.next.val == val) &#123;</span><br><span class="line">                l.next = l.next.next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l = l.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、双指针</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ol>
<li><strong>定位节点：</strong> 遍历链表，直到 <code>head.val == val</code> 时跳出，即可定位目标节点。</li>
<li><strong>修改引用：</strong> 设节点 <code>cur</code> 的前驱节点为 <code>pre</code> ，后继节点为 <code>cur.next</code> ；则执行 <code>pre.next = cur.next</code> ，即可实现删除 <code>cur</code> 节点。</li>
</ol>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> N 为链表长度，删除操作平均需循环 N&#x2F;2 次，最差 N 次。</li>
<li><strong>空间复杂度 O(1)</strong></li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteNode</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head.val == val) <span class="keyword">return</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head, cur = head.next;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> &amp;&amp; cur.val != val) &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="literal">null</span>) pre.next = cur.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>双指针</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>包含min函数的栈</title>
    <url>/2022/05/21/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/21/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/image-20220521102533380.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、解法一：最笨方法，遍历栈实现</strong>（时间复杂度O(n)）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack.empty())&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> (<span class="type">int</span>) stack.peek();</span><br><span class="line">        <span class="keyword">return</span> peek;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack.empty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">for</span> (Integer x : stack) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x &lt; min) &#123;</span><br><span class="line">                    min = x;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、解法二：多加一个栈，时间复杂度从O(n)变到O(1)</strong> （优解）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1= <span class="literal">null</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">        <span class="keyword">if</span> (stack2.empty() || stack2.peek() &gt;= x) &#123;</span><br><span class="line">            stack2.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack1.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (stack1.peek().equals(stack2.peek()))&#123;</span><br><span class="line">                stack2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stack1.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> (<span class="type">int</span>) stack1.peek();</span><br><span class="line">        <span class="keyword">return</span> peek;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack1.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> stack2.peek();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
        <category>栈与队列</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521104938106.png" class title="examplename"></em></p>
<h4 id="解题："><a href="#解题：" class="headerlink" title="解题："></a>解题：</h4><p><strong>1、时间复杂度为O(n)的复杂方法</strong></p>
<ul>
<li><p>使用栈切换顺序，然后存入另一个ListNode，输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode head1;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="literal">null</span>;</span><br><span class="line">            stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">while</span> (!(head == <span class="literal">null</span>)) &#123;</span><br><span class="line">                stack.push(head.val);</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stack.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(stack.pop());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.head1 == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.head1 = node;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>.head1;</span><br><span class="line">                    <span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                        cur = cur.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur.next = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.head1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用递归实现,然后存入另一个ListNode，输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> ListNode head1;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        recur(head);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tmp.size(); i++) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(tmp.get(i));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.head1 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.head1 = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>.head1;</span><br><span class="line">                <span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                    cur = cur.next;</span><br><span class="line">                &#125;</span><br><span class="line">                cur.next = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.head1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">recur</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        recur(head.next);</span><br><span class="line">        tmp.add(head.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、时间复杂度为O(n)的优化解法</strong></p>
<ul>
<li><p><strong>使用迭代（双指针）</strong></p>
<ul>
<li><p><strong>时间复杂度 O(N) ：</strong> 遍历链表使用线性大小时间。</p>
</li>
<li><p><strong>空间复杂度 O(1) ：</strong> 变量 <code>pre</code> 和 <code>cur</code> 使用常数大小额外空间。</p>
</li>
<li><p><strong>解题思路：</strong></p>
<ul>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105437651.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105456441.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105509583.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105524848.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105531721.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105538707.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105545101.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105551927.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105558024.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105604074.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105610816.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105616249.png" class title="examplename"></em></li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">nextNode</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>使用递归，时间复杂度O(n)</strong></p>
<ul>
<li><p>**时间复杂度：O(n)**，其中 n 是链表的长度。需要对链表的每个节点进行反转操作。</p>
</li>
<li><p>**空间复杂度：O(n)**，其中 n 是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 n层。</p>
</li>
<li><p><strong>解题思路：</strong></p>
<ul>
<li><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521110806821.png" class title="examplename"></li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个排序的链表</title>
    <url>/2022/05/29/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/29/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/image-20220529144911252.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、哨兵节点</strong></p>
<ul>
<li><p><strong>解题思路：</strong>设置一个哨兵节点，设置一个结点l指向哨兵节点，因为l1和l2是有序的，顺序比较l1和l2中节点的大小，使得l与之相连，最后返回哨兵的next即可！</p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(M+N) ：</strong> M, N 分别为链表 l1, l2的长度，合并操作需遍历两链表。</li>
<li><strong>空间复杂度 O(1)</strong></li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  ListNode next;</span><br><span class="line">  ListNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt; l2.val ) &#123;</span><br><span class="line">                l.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            l = l.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走到这里，说明l1或l2肯定有一个已经为null，故直接连接那个有的就ok了</span></span><br><span class="line">        l.next = l1 != <span class="literal">null</span> ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>双指针</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>和为s的两个数字</title>
    <url>/2022/05/30/%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/30/%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/image-20220530101826170.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、双指针</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ol>
<li>计算和 s &#x3D; nums[i] + nums[j]；</li>
<li>若 s &gt; target ，则指针 j 向左移动，即执行 j &#x3D; j - 1；</li>
<li>若 s &lt; target，则指针 i 向右移动，即执行 i &#x3D; i + 1；</li>
<li>若 s &#x3D; target ，立即返回数组 [nums[i], nums[j]]；</li>
</ol>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> N 为数组 nums 的长度；双指针共同线性遍历整个数组。</li>
<li><strong>空间复杂度 O(1) ：</strong> 变量 i, j 使用常数大小的额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 提前把大于target的排除，也可防止nums[i] + nums[j]时溢出</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; target &lt; nums[j]) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="comment">// 这个s很重要，如果这样写，后面判断都得计算nums[i] + nums[j]，效率将会降低</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> nums[i] + nums[j];</span><br><span class="line">            <span class="keyword">if</span> (s &gt; target)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s &lt; target)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;nums[i],nums[j]&#125;;<span class="comment">// 不在前面定义，可以动态的节省空间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>双指针</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>在排序数组中查找数字1</title>
    <url>/2022/05/22/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%971/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/22/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%971/image-20220522200203070.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、二分法</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li>使用二分法分别找到 左边界 left和 右边界 right ，易得数字 target 的数量为right−left−1 。</li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(log N)：</strong> 二分法为对数级别复杂度。</li>
<li><strong>空间复杂度 O(1)：</strong> 几个变量使用常数大小的额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">firstPosition</span> <span class="operator">=</span> findFirstPosition(nums,target);</span><br><span class="line">        <span class="keyword">if</span> (firstPosition == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastPosition</span> <span class="operator">=</span> findLastPosition(nums,target);</span><br><span class="line">        <span class="keyword">return</span> lastPosition - firstPosition + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找target第一次出现的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findFirstPosition</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &gt; left)&#123;</span><br><span class="line">            <span class="comment">// 这样写避免left+right在值很大的时候整型溢出</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                <span class="comment">// [mid+1 ... right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// [left ... mid]</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[left] == target) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找target最后一次出现的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findLastPosition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &gt; left)&#123;</span><br><span class="line">            <span class="comment">// 这样写避免left+right在值很大的时候整型溢出</span></span><br><span class="line">            <span class="comment">// 将mid赋值给left的时候要向上取整，不然left可能永远小于right，也就永远跳不出循环</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">                <span class="comment">// [mid ... right]</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// [left ... mid-1]</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为int firstPosition = findFirstPosition(nums,target);已经找到target了，所以必有target，直接返回left即可。</span></span><br><span class="line">        <span class="comment">//if (nums[left] == target) &#123;</span></span><br><span class="line">        <span class="comment">//    System.out.println(left);</span></span><br><span class="line">        <span class="comment">//    return left;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//return -1;</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//@Test</span></span><br><span class="line">    <span class="comment">//void test() &#123;</span></span><br><span class="line">    <span class="comment">//        int[] nums = &#123;5,7,7,8,8,10&#125;;</span></span><br><span class="line">    <span class="comment">//    int search = this.search(nums, 8);</span></span><br><span class="line">    <span class="comment">//    System.out.println(search);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>查找算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂链表的复制</title>
    <url>/2022/05/21/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/21/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/image-20220521182707888.png" class title="examplename"></em></p>
<p><em><img src="/2022/05/21/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/image-20220521182758490.png" class title="examplename"></em></p>
<p><em><img src="/2022/05/21/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/image-20220521182825269.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>​		本题中因为随机指针的存在，当我们拷贝节点时，「当前节点的随机指针指向的节点」可能还没创建，因此我们需要变换思路。</p>
<p><strong>1、回溯 + 哈希表</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li>一个可行方案是，我们利用回溯的方式，让每个节点的拷贝操作相互独立。对于当前节点，我们首先要进行拷贝，然后我们进行「当前节点的后继节点」和「当前节点的随机指针指向的节点」拷贝，拷贝完成后将创建的新节点的指针返回，即可完成当前节点的两指针的赋值。</li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n)，其中 n 是链表的长度。对于每个节点，我们至多访问其「后继节点」和「随机指针指向的节点」各一次，均摊每个点至多被访问两次。</li>
<li><strong>空间复杂度：</strong>O(n)，其中 n 是链表的长度。为哈希表的空间开销。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回溯 + 哈希表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    Map&lt;Node, Node&gt; cachedNode = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node, Node&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!cachedNode.containsKey(head)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">headNew</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(head.val);</span><br><span class="line">            cachedNode.put(head, headNew);</span><br><span class="line">            headNew.next = copyRandomList(head.next);</span><br><span class="line">            headNew.random = copyRandomList(head.random);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cachedNode.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、迭代 + 节点拆分</strong>（方法很nice）</p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li><em><img src="/2022/05/21/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/image-20220521183343757.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/image-20220521191723967.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/image-20220521191905643.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/image-20220521191958997.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/image-20220521192018933.png" class title="examplename"></em></li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 是链表的长度。我们只需要遍历该链表三次。</li>
<li>空间复杂度：O(1)。注意返回值不计入空间复杂度</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完成链表节点的复制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head; cur != <span class="literal">null</span>; cur = cur.next.next) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val);</span><br><span class="line">            newNode.next = cur.next;</span><br><span class="line">            cur.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完成链表复制节点的随机指针复制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;cur != <span class="literal">null</span>; cur = cur.next.next) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            newNode.random = (cur.random != <span class="literal">null</span>)?cur.random.next:<span class="literal">null</span>; <span class="comment">// cur.random为空，空节点不能.next，否则会报错</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">headNew</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">// 将链表一分为二</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head; cur != <span class="literal">null</span>; cur = cur.next) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = newNode.next;</span><br><span class="line">            newNode.next = (cur.next != <span class="literal">null</span>)? cur.next.next:<span class="literal">null</span>; <span class="comment">// 这里判断同理</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> headNew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>对称的二叉树</title>
    <url>/2022/05/26/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/26/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220526084728325.png" class title="examplename"></em></p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p><strong>1、辅助队列</strong></p>
<ul>
<li><p><strong>解题思路：将每一层数据放入集合，因为对称，集合左和集合右正好相反</strong></p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> N 为二叉树的节点数量，即 BFS 需循环 N 次，占用 O(N) 。</li>
<li><strong>空间复杂度 O(N)</strong></li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>() &#123;&#123;</span><br><span class="line">            add(root);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 每次循环都创建一个新的集合，每次放树每一层的数。</span></span><br><span class="line">            <span class="type">List</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果结点为null，直接给tmp赋-1，退出当前循环</span></span><br><span class="line">                <span class="keyword">if</span>( poll == <span class="literal">null</span>) &#123;</span><br><span class="line">                    tmp.add(-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果结点不为null，则将结点的值给tmp</span></span><br><span class="line">                <span class="keyword">if</span>(poll != <span class="literal">null</span>) &#123;</span><br><span class="line">                    tmp.add(poll.val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只要结点不为空，就将结点的左右子结点存入队列，如果子孩子结点为null，直接给tmp赋-1，退出当前循环</span></span><br><span class="line">                <span class="keyword">if</span>(poll != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(poll.left);</span><br><span class="line">                    queue.add(poll.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将树该层的tmp，因为是对称的，所以分开两部分，然后比较后一部分的反转和前一部分是否相等，相等则继续，直到队列为空，说明全部遍历结束，是对称的，返回true</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> tmp.size() / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tmp.size() % <span class="number">2</span> == <span class="number">0</span> ) &#123;</span><br><span class="line">                List&lt;Integer&gt; a = tmp.subList(<span class="number">0</span>, size);</span><br><span class="line">                List&lt;Integer&gt; b = tmp.subList(size , tmp.size());</span><br><span class="line">                Collections.reverse(b);</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">equals</span> <span class="operator">=</span> a.equals(b);</span><br><span class="line">                <span class="keyword">if</span> (equals == <span class="literal">true</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、递归法</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li>对称二叉树定义： 对于树中 任意两个对称节点 L 和 R ，一定有：<ul>
<li>L.val &#x3D; R.val：即此两对称节点值相等。</li>
<li>L.left.val &#x3D; R.right.val ：即 L 的 左子节点 和 R 的 右子节点 对称；</li>
<li>L.right.val &#x3D; R.left.val ：即 L 的 右子节点 和 R 的 左子节点 对称。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><p><strong>时间复杂度 O(N) ：</strong> 其中 NN 为二叉树的节点数量，每次执行 recur() 可以判断一对节点是否对称，因此最多调用 N&#x2F;2 次 recur() 方法。</p>
</li>
<li><p><strong>空间复杂度 O(N) ：</strong> 最差情况下（见下图），二叉树退化为链表，系统使用 O(N) 大小的栈空间。</p>
</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 根节点为空直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recur(root.left,root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return root == null ? true : recur(root.left, root.right);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">recur</span><span class="params">(TreeNode L, TreeNode R)</span> &#123;</span><br><span class="line">        <span class="comment">// 当 L 和 R 同时越过叶节点： 此树从顶至底的节点都对称，因此返回 true;</span></span><br><span class="line">        <span class="keyword">if</span> (L == <span class="literal">null</span> &amp;&amp; R == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当 L 或 R 中只有一个越过叶节点: 此树不对称;当节点 L 值 != 节点 R 值： 此树不对称;返回false</span></span><br><span class="line">        <span class="keyword">if</span> (L == <span class="literal">null</span> || R == <span class="literal">null</span> || L.val != R.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左 = 右，右 = 左</span></span><br><span class="line">        <span class="keyword">return</span> recur(L.left,R.right) &amp;&amp; recur(L.right,R.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>搜索与回溯</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>应战秋招总结</title>
    <url>/2022/04/21/%E5%BA%94%E6%88%98%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="1、何为秋招？"><a href="#1、何为秋招？" class="headerlink" title="1、何为秋招？"></a>1、何为秋招？</h2><h3 id="1-1、应届生"><a href="#1-1、应届生" class="headerlink" title="1.1、应届生"></a>1.1、应届生</h3><p>暑假：大学生（实习、工作）</p>
<span id="more"></span>

<p>8月、春招！</p>
<p>应届毕业生！</p>
<p>2015年级 2019界 2016年级 2020界</p>
<p>应届毕业生： 大三升大四！</p>
<p><strong>大三暑假找工作找实习！</strong></p>
<p>大四：毕业再找！切记、不好！</p>
<p>2020校招！不收2019届！</p>
<h3 id="1-2、秋招-x2F-春招-x2F-校招"><a href="#1-2、秋招-x2F-春招-x2F-校招" class="headerlink" title="1.2、秋招&#x2F;春招&#x2F;校招"></a>1.2、秋招&#x2F;春招&#x2F;校招</h3><p>校招： 校园招聘</p>
<p>流程：网申-笔试-面试（23轮）-录取通知-体检-签三方-毕业！-上班！ 秋招： 7来年一月 7~10，校招核心！</p>
<p>秋招名额远大于春招！</p>
<p>招聘信息 宣讲会 招聘会</p>
<p>春招： 春节到6月 3~4、秋招补录！</p>
<blockquote>
<p>网申（不打无准备的仗）</p>
</blockquote>
<p>网络在线申请，大型企业！</p>
<p>注意：填表格！</p>
<p>开放性问题：优缺点？失败经历？公司的看法？</p>
<p>一定要仔细？大三时候就一定要准备好！</p>
<p>复制到记事本！</p>
<blockquote>
<p>宣讲会</p>
</blockquote>
<p>公司 HR、技术！ 讲解公司的内容、岗位、待遇、Q&amp;A？</p>
<p>1、开完就走！</p>
<p>2、现场接受简历</p>
<p>3、现场接受简历、面试！一分钟（记住你！ 准备60s的自我介绍）</p>
<p>4、现场接受简历、面试、笔试！</p>
<p><strong>多跑!</strong></p>
<blockquote>
<p>招聘会（多对一）体验一次！</p>
</blockquote>
<p>政府: 人力资源组织 ! 现场招聘&#x2F;网络招聘</p>
<p><strong>现场招聘</strong></p>
<p>综合&#x2F;理工科&#x2F;经管文科</p>
<p><strong>准备：</strong></p>
<p>HR、直接递交简历。现场面试， hR！</p>
<p>1、简历！</p>
<p>2、带上U盘！资料文件！防备不时之需</p>
<p>3、目标确定性： 1000家公司（2~3 公司的信息、岗位需要的职业技能！） 简历是可以改变的！（掌握技能、实习工作经历） 3个公司、3份不一样的（根据公司的需要来定 制！）</p>
<h3 id="1-3、社招-x2F-海投"><a href="#1-3、社招-x2F-海投" class="headerlink" title="1.3、社招&#x2F;海投"></a>1.3、社招&#x2F;海投</h3><blockquote>
<p>社招： 社会招聘！ 目标人群： 毕业的人、经验人士！</p>
</blockquote>
<p>社招持续存在！</p>
<p>社招: 校招是有新人培训！社招直接进去就工作！ 一定都是招收有经验的人士！</p>
<p>参加校招：大四！不要在毕业之后！</p>
<p>大三~大四！重视校招！</p>
<p>社招: 猎头、打造知名度（开源项目、博客、媒体影响力！）</p>
<blockquote>
<p>海投: 广撒网！</p>
</blockquote>
<p>不建议：没有针对！</p>
<p>百度、阿里：做了准备、历届面试题、实训！</p>
<p>投的数量多不一定有用！</p>
<p>不打无准备的仗： 秋招、社招（选定心仪的公司！ 2~3）</p>
<p>1、集中精力研究这些公司的面试！</p>
<p>2、努力提升自己的技能！拿到再多的oﬀer ，最终你只能选择一家！ 面试！一开始就选择了！</p>
<p>100家公司！ 没有人鸟你，自我否定！</p>
<h2 id="2、秋招信息如何获取？"><a href="#2、秋招信息如何获取？" class="headerlink" title="2、秋招信息如何获取？"></a>2、秋招信息如何获取？</h2><p>秋招：获取秋招信息</p>
<p>1、公司官网+官方招聘公众号！正规</p>
<p>2、内推（熟人内部推荐！群里&#x2F;公众号）学长、学姐</p>
<p>3、牛客网！专业的网站去找咨询！</p>
<p>牛客求职区：<a href="https://www.nowcoder.com/recommend">https://www.nowcoder.com/recommend</a></p>
<p>牛客讨论区：<a href="https://www.nowcoder.com/discuss">https://www.nowcoder.com/discuss</a></p>
<p>校招日程汇总：<a href="https://www.nowcoder.com/school/schedule">https://www.nowcoder.com/school/schedule</a></p>
<p>大数据：筛选出有用的消息！</p>
<p>不要超过5家公司！</p>
<p>百度、阿里、腾讯、美团、京东</p>
<p><strong>到社会上第一步: 选择</strong></p>
<p>1、钱多事少离家近 （钱多）</p>
<p>2、背书，大公司！ 证明！</p>
<p>3、锻炼自己！<br>工资 、能力对等！</p>
<h2 id="3、如何备战秋招？"><a href="#3、如何备战秋招？" class="headerlink" title="3、如何备战秋招？"></a>3、如何备战秋招？</h2><h3 id="3-1、简历（ps做简历）"><a href="#3-1、简历（ps做简历）" class="headerlink" title="3.1、简历（ps做简历）"></a>3.1、简历（ps做简历）</h3><p><strong>1、模板！</strong></p>
<ul>
<li>word 黑白字！</li>
<li>一定要找一个稳健的模板（工作相关的模板）</li>
<li>尽量不要太多（最多2~3张&#x2F; 1张能解决是最好的）</li>
<li>突出主题（线上发邮件：PDF！不要发word、文字乱码！）</li>
<li>颜值高、照片！（大学都去拍摄一组正装的艺术照！）</li>
<li>不同的公司岗位你要写不同的简历！</li>
<li>内容：<ul>
<li>个人信息： 姓名、求职岗位、手机号、邮箱地址（突出显示、一下子就能看到自己的联系方式）</li>
<li>学校的学历： 毕业院校、本科：直接写本科院校：研究生：本科毕业院校、研究生毕业院校。有的公司敲门砖就是 985&#x2F;211<ul>
<li>问题：我的学校不够好？ 学校不是最致命的条件、毕业院校不是很好（重点就是 实习经历+项目经历</li>
</ul>
</li>
<li>博客&#x2F;影响力的东西：一定要突出！（价值） 学习一定要产出！</li>
<li>实习经历：（重中之重）<ul>
<li>大厂实习经历！最好的！</li>
<li>假设没有实习经历。 突出项目经历！</li>
<li>项目经历： 自己在学校做过哪些项目 真实，自己做过哪些项目经历</li>
<li>切记不要流水账！<ul>
<li>我做了什么项目</li>
<li>我在项目中负责那一部分</li>
<li>在项目开发中遇到了哪些难题 我是怎么处理和解决的！</li>
</ul>
</li>
<li>不要伪造（培训机构出来的人，大部分都会伪造项目经历和工作年龄！）</li>
</ul>
</li>
</ul>
</li>
<li>校园经历：<ul>
<li>学生会、社团。自己在学校举办的活动。</li>
<li>获奖经历。</li>
<li>奖学金</li>
</ul>
</li>
<li>掌握的技能<ul>
<li>如实的写</li>
<li>熟悉、精通（少用精通，最多1~2个精通！）</li>
<li>面试会通过这个来问你！</li>
<li>不要在这里给自己挖坑！</li>
</ul>
</li>
</ul>
<p>2、真实！</p>
<p>3、措辞！</p>
<h3 id="3-2、笔试准备"><a href="#3-2、笔试准备" class="headerlink" title="3.2、笔试准备"></a>3.2、笔试准备</h3><p>技术岗（编程和问答！）</p>
<p>解决方法：看书+练题！多锻炼自己的说话能力！</p>
<p>练题不要瞎练习：针对性练习题目</p>
<p>目标：</p>
<p>找到历届的笔试面试题！ 提前3个月做准备！ 刷题+属性以前的套路！</p>
<ul>
<li><p>名企笔试真题练习：<a href="https://www.nowcoder.com/contestRoom">https://www.nowcoder.com/contestRoom</a></p>
</li>
<li><p>校招笔试真题汇总：<a href="https://www.nowcoder.com/contestRoom?mutiTagIds=1657">https://www.nowcoder.com/contestRoom?mutiTagIds=1657</a></p>
</li>
</ul>
<p>校招备战学习计划：<a href="https://www.nowcoder.com/studypath/1">https://www.nowcoder.com/studypath/1</a></p>
<ul>
<li><p>在线编程：<a href="https://www.nowcoder.com/activity/oj">https://www.nowcoder.com/activity/oj</a></p>
</li>
<li><p>剑指oﬀer在线编程：<a href="https://www.nowcoder.com/ta/coding-interviews">https://www.nowcoder.com/ta/coding-interviews</a></p>
</li>
</ul>
<p>不打无准备的仗！</p>
<p>算法很重要，没有套路，就是多刷题！一定要多花时间研究！</p>
<p>大学生：4年！</p>
<p>大一大二就扎实学习基础技能！</p>
<p>大三了解公司，了解面试，刷题！</p>
<p>大三暑假：找实习找工作</p>
<p>大四就是毕业、交朋友、熟悉公司、到社会！</p>
<h3 id="3-3、面试准备"><a href="#3-3、面试准备" class="headerlink" title="3.3、面试准备"></a>3.3、面试准备</h3><p>多看面经！</p>
<p>每个公司的面试风格都不同！</p>
<ul>
<li><p>牛客讨论区：<a href="https://www.nowcoder.com/discuss">https://www.nowcoder.com/discuss</a></p>
</li>
<li><p>各岗位汇总目录：<a href="https://www.nowcoder.com/discuss/167046">https://www.nowcoder.com/discuss/167046</a></p>
</li>
<li><p>各公司面经汇总目录：<a href="https://www.nowcoder.com/discuss/161635">https://www.nowcoder.com/discuss/161635</a></p>
</li>
</ul>
<p>1、多看他人的面经？</p>
<p>2、善于总结自己的面试经验？多分享（交流）</p>
<p>练手：</p>
<p>中意大公司，面试很紧张！</p>
<p>去小公司面试锻炼：慢慢找到自己的不足，锻炼经验，保证自己面试不经常！</p>
<p>练到自己不紧张不惧怕面试了就可以去自己中意的公司面试！</p>
<p>要把最好的状态留个最重要的面试！</p>
<p>面试：不断地打击自信心的过程！</p>
<p>千万不要对自己失去信心！</p>
<p>最黑暗时刻、就是黎明前！</p>
<p>坚持：多找自己的问题，弥补不足，在尝试！</p>
<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>1、秋招时机，提前批、内推、公众平台、社会招聘、…… 信息很重要！</p>
<p>2、早些做好自己的职业规划（大三之前）</p>
<p>3、写一个优秀的简历。不是自我介绍，而是让公司看到简历之后知道为什么需要你！简历是可以有多 份！</p>
<p>4、笔试和面试尽量提前3个月准备充分！提前了解公司！<br>参考链接：<a href="https://www.bilibili.com/video/BV16C4y1t7Mi%EF%BC%8C%E8%B5%84%E6%BA%90%E6%9D%A5%E8%87%AA**%E7%8B%82%E7%A5%9E%E8%AF%B4**yyds%EF%BC%81">https://www.bilibili.com/video/BV16C4y1t7Mi，资源来自**狂神说**yyds！</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>招聘</tag>
      </tags>
  </entry>
  <entry>
    <title>左旋转字符串</title>
    <url>/2022/05/21/%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/21/%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20220521201003026.png" class title="examplename"></em></p>
<h4 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、字符串切片</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> s.substring(<span class="number">0</span>, n);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.substring(n,s.length());</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s2 + s1;</span><br><span class="line">        <span class="keyword">return</span> s3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、列表遍历拼接</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &lt; s.length(); i++) &#123;</span><br><span class="line">            s3.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            s3.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s3.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、字符串遍历拼接</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &lt; s.length(); i++) &#123;</span><br><span class="line">            s3 += s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            s3 += s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>总结常见的队列方法</title>
    <url>/2022/05/24/%E6%80%BB%E7%BB%93%E5%B8%B8%E8%A7%81%E7%9A%84%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<p><em><img src="/2022/05/24/%E6%80%BB%E7%BB%93%E5%B8%B8%E8%A7%81%E7%9A%84%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95/image-20220525084608238.png" class title="examplename"></em></p>
<blockquote>
<p>Queue<Object> queue &#x3D; new LinkedList&lt;&gt;();</Object></p>
</blockquote>
<ul>
<li><p>add 增加一个元素 如果队列已满，则抛出一个IIIegaISlabEepeplian异常</p>
</li>
<li><p>remove 移除并返回队列头部的元素 如果队列为空，则抛出一个 NoSuchElementException</p>
</li>
<li><p>element 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常</p>
</li>
<li><p>offer 添加一个元素并返回true 如果队列已满，则返回false</p>
</li>
</ul>
<ul>
<li>poll 移除并返问队列头部的元素 如果队列为空，则返回null</li>
<li>peek 返回队列头部的元素 如果队列为空，则返回null</li>
<li>put 添加一个元素 如果队列满，则阻塞</li>
<li>take 移除并返回队列头部的元素 如果队列为空，则阻塞</li>
</ul>
<blockquote>
<p>Deque<Object> deque&#x3D; new LinkedList&lt;&gt;();</Object></p>
</blockquote>
<p>Deque是Queue的子接口，新增方法：</p>
<p>*<img src="/2022/05/24/%E6%80%BB%E7%BB%93%E5%B8%B8%E8%A7%81%E7%9A%84%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95/image-20220525084444032.png" class title="examplename"></p>
<p>​	</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>把数字翻译成字符串</title>
    <url>/2022/05/28/%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/28/%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20220528090513986.png" class title="examplename"></em></p>
<p><strong>题解</strong></p>
<ul>
<li><strong>解题总统思路：</strong><ul>
<li><em><img src="/2022/05/28/%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20220528090608388.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/28/%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20220528090717826.png" class title="examplename"></em></li>
</ul>
</li>
</ul>
<p><strong>1、字符串遍历</strong></p>
<ul>
<li><p><strong>解题思路：</strong>为方便获取数字的各位 xi，考虑先将数字 num 转化为字符串 s ，通过遍历 s 实现动态规划</p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> N 为字符串 s 的长度（即数字 num 的位数 log(num) ），其决定了循环次数。</li>
<li><strong>空间复杂度 O(N) ：</strong> 字符串 s 使用 O(N)大小的额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">translateNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先将num变成字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(num);</span><br><span class="line">        <span class="comment">// 设置 b“无数字” 和 a“第 1 位数字” 的翻译方法数量均为 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>,b = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从后往前循环，计算翻译方法的数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">2</span>; i &gt; -<span class="number">1</span> ; i--) &#123;</span><br><span class="line">            <span class="comment">// 取到 i+2 的前两个数字</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> s.substring(i, i + <span class="number">2</span>);</span><br><span class="line">            <span class="comment">// 判断这俩个数字组合以后ASCII码差值是否在10~25之间</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> tmp.compareTo(<span class="string">&quot;10&quot;</span>) &gt;= <span class="number">0</span> &amp;&amp; tmp.compareTo(<span class="string">&quot;25&quot;</span>) &lt;= <span class="number">0</span> ? a + b : a;</span><br><span class="line">            b = a;</span><br><span class="line">            a = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、数字求余</strong>（降低空间复杂度O(n)–&gt;O(1)）</p>
<ul>
<li><p><strong>解题思路：</strong>利用求余运算 num % 10 和求整运算 num &#x2F; 10 ，可获取数字 num 的各位数字（获取顺序为个位、十位、百位…）。</p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> N 为字符串 s 的长度（即数字 num 的位数 log(num) ），其决定了循环次数。</li>
<li><strong>空间复杂度 O(N) ：</strong>  几个变量使用常数大小的额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数字求余</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">translateNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置 b“无数字” 和 a“第 1 位数字” 的翻译方法数量均为 1，x十位，y个位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>,b = <span class="number">1</span>,x,y = num % <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 从后往前循环，计算翻译方法的数量</span></span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 拿到x的值</span></span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">            x = num % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 总值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> x * <span class="number">10</span> + y;</span><br><span class="line">            <span class="comment">// 判断这俩个数字组合以后是否在10~25之间</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> tmp &gt;= <span class="number">10</span> &amp;&amp; tmp &lt;= <span class="number">25</span> ? a + b : a;</span><br><span class="line">            b = a;</span><br><span class="line">            a = c;</span><br><span class="line">            y = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中重复的数字</title>
    <url>/2022/05/22/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/22/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/image-20220522075236430.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、哈希表 &#x2F; Set</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用set.contains方法判断</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:</span><br><span class="line">             nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(num)) &#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;<span class="keyword">else</span> set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用set集合中不能有重复的特性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">repeat</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(num)) &#123;</span><br><span class="line">                repeat = num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> repeat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>复杂度分析：</strong><ul>
<li>**时间复杂度 O(N)**： 遍历数组使用 O(N) ，HashSet 添加与查找元素皆为 O(1)。</li>
<li>**空间复杂度 O(N)**： HashSet 占用 O(N) 大小的额外空间。</li>
</ul>
</li>
</ul>
<p><strong>2、原地交换</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li>可遍历数组并通过交换操作，使元素的 索引 与 值 一一对应（即 nums[i]&#x3D;i ）。因而，就能通过索引映射对应的值，起到与字典等价的作用。</li>
<li><em><img src="/2022/05/22/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/image-20220522080700921.png" class title="examplename"></em></li>
<li>遍历中，第一次遇到数字 x 时，将其交换至索引 x 处；而当第二次遇到数字 x 时，一定有 nums[x]&#x3D;x ，此时即可得到一组重复数字。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原地交换</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums.length)&#123;</span><br><span class="line">            <span class="comment">//  说明此数字已在对应索引位置，无需交换，因此跳过</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == i) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断索引为nums[i]的是否与索引为i的相等，相等说明索引nums[i]已经有与nums[i]的值相等的了，即有重复的了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[nums[i]] == nums[i]) <span class="keyword">return</span> nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i] = nums[tmp];</span><br><span class="line">            nums[tmp] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>复杂度分析</strong>：</p>
<ul>
<li>**时间复杂度 O(N)**： 遍历数组使用 O(N) ，每轮遍历的判断和交换操作使用 O(1)。</li>
<li>**空间复杂度 O(1)**： 使用常数复杂度的额外空间。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>查找算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>斐波那契数列</title>
    <url>/2022/05/26/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/26/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/image-20220526103227660.png" class title="examplename"></em></p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p><strong>1、递归法（提交超时）</strong></p>
<ul>
<li><p><strong>解题思路：</strong>把 f(n) 问题的计算拆分成 f(n-1) 和 f(n-2) 两个子问题的计算，并递归，以 f(0) 和 f(1) 为终止条件。</p>
<ul>
<li>递归法会造成大量的重复计算，比如就计算fib(6)为例来看下</li>
<li><em><img src="/2022/05/26/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/image-20220526105439394.png" class title="examplename"></em></li>
<li>我们看到上面相同颜色的都是重复计算，当n越大，重复的越多</li>
</ul>
</li>
<li><p><strong>时间复杂度分析：</strong></p>
<ul>
<li>时间复杂度O(2^n)：二叉树的高度是 n - 1，一个高度为k的二叉树最多可以由 2^k - 1个叶子节点，也就是递归过程函数调用的次数，所以时间复杂度为 O(2^n)。</li>
<li>空间复杂度 O(n)：就是树的高度。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归法1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> fib(n-<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> fib(n-<span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、记忆化递归法：</strong></p>
<ul>
<li><p><strong>解题思路：</strong>当n越大，重复的越多，所以我们可以使用一个map把计算过的值存起来，每次计算的时候先看map中有没有，如果有就表示计算过，直接从map中取，如果没有就先计算，计算完之后再把结果存到map中。</p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度O(n)：</strong>每次都只加2，故为O(n+2)，即O(n)</li>
<li><strong>空间复杂度 O(n)：</strong>就是树的高度。</li>
</ul>
</li>
<li><p><strong>优化代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归法2，优化，加入一个map集合用来存储之前算个的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fib(n,<span class="keyword">new</span> <span class="title class_">HashMap</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n,Map&lt;Integer,Integer&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(n)) <span class="keyword">return</span> map.get(n);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> fib(n-<span class="number">1</span>,map);</span><br><span class="line">        map.put(n-<span class="number">1</span>,a);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> fib(n-<span class="number">2</span>,map);</span><br><span class="line">        map.put(n-<span class="number">2</span>,b);</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">        map.put(n,c);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3、动态规划法</strong></p>
<ul>
<li><p><strong>解题思路：</strong>以斐波那契数列性质 f(n + 1) &#x3D; f(n) + f(n - 1)为转移方程。</p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> 计算 f(n)f(n) 需循环 n 次，每轮循环内计算操作使用 O(1)。</li>
<li><strong>空间复杂度 O(1) ：</strong> 几个标志变量使用常数大小的额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 记录每次的a+b，避免重复计算</span></span><br><span class="line">        <span class="type">int</span> sum;</span><br><span class="line">        <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum = (a+b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转数组的最小数字</title>
    <url>/2022/05/23/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/23/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/image-20220523193220775.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、使用二分法+暴力</strong></p>
<ul>
<li><p><strong>解题思路：</strong>寻找旋转数组的最小元素即为寻找 <strong>右排序数组</strong> 的首个元素 nums[x] ，称 x为 <strong>旋转点</strong> 。</p>
<ul>
<li><em><img src="/2022/05/23/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/image-20220523193434233.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/23/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/image-20220523193527081.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/23/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/image-20220523193553110.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/23/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/image-20220523193607494.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/23/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/image-20220523193631168.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/23/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/image-20220523193645968.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/23/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/image-20220523193706028.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/23/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/image-20220523193721084.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/23/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/image-20220523193737369.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/23/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/image-20220523193753498.png" class title="examplename"></em></li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(log_2 N) ：</strong> 在特例情况下（例如 [1, 1, 1, 1]），会退化到 O(N)。</li>
<li><strong>空间复杂度 O(1)：</strong> i , j , mid 变量使用常数大小的额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分法求解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minArray</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> i + (j-i) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] &lt; numbers[j]) &#123;</span><br><span class="line">                j = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; numbers[j]) &#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>补充思考： 为什么本题二分法不用 nums[mid] 和 nums[i] 作比较？</strong></p>
<p>​	二分目的是判断 mid 在哪个排序数组中，从而缩小区间。而在 nums[m] &gt; nums[i]情况下，无法判断 mid 在哪个排序数组中。本质上是由于 j 初始值肯定在右排序数组中； i 初始值无法确定在哪个排序数组中。举例如下：</p>
<blockquote>
<p>对于以下两示例，当 i &#x3D; 0, j &#x3D; 4, mid &#x3D; 2 时，有 nums[m] &gt; nums[i] ，而结果不同。</p>
<p>[1, 2, 3, 4 ,5] 旋转点 x &#x3D; 0 ： m 在右排序数组（此示例只有右排序数组）； </p>
<p>[3, 4, 5, 1 ,2] 旋转点 x &#x3D; 3 ： m 在左排序数组。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>查找算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>替换空格</title>
    <url>/2022/05/21/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/21/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/image-20220521190640793.png" class title="examplename"></em></p>
<h4 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h4><p><strong>1、调用代码库</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        s = s.replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、字符数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 每次替换从 1 个字符变成 3 个字符，所以需要3倍的大小</span></span><br><span class="line">        <span class="type">char</span>[] array = <span class="keyword">new</span> <span class="title class_">char</span>[s.length() * <span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() ; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                array[size++] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                array[size++] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                array[size++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> array[size++] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array, <span class="number">0</span>, size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂性分析</strong></p>
<ul>
<li>**时间复杂度：O(n)**。遍历字符串 <code>s</code> 一遍。</li>
<li>**空间复杂度：O(n)**。额外创建字符数组，长度为 <code>s</code> 的长度的 3 倍。</li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最长不含重复字符的子字符串</title>
    <url>/2022/05/28/%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/28/%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20220528210844419.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、滑动窗口 + 哈希表</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li>滑动窗口，用set维护一个不重复的窗口，如果已经包含该字符，将该字符相等的字符之前的以及此字符元素全部移除，然后记录set的大小最大的就是最长不含重复字符的子字符串数。</li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度<em>O</em>(<em>N</em>)：</strong>其中 <em>N</em> 是字符串的长度。</li>
<li><strong>空间复杂度O(∣Σ∣)：</strong>，其中 Σ 表示字符集（即字符串中可以出现的字符），∣Σ∣ 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0, 128)内的字符，即 ∣Σ∣&#x3D;128。我们需要用到哈希集合来存储出现过的字符，而字符最多有 ∣Σ∣ 个，因此空间复杂度为 O(∣Σ∣)。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口 + 哈希表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 滑动窗口，用set维护一个不重复的窗口</span></span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="comment">// 如果已经包含c，将与c相等的字符之前的元素以及此字符元素全部移除</span></span><br><span class="line">            <span class="keyword">while</span>(set.contains(c)) &#123;</span><br><span class="line">                set.remove(s.charAt(l++));</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(c);</span><br><span class="line">            <span class="comment">// 或者这样写 res = Math.max(res,set.size());</span></span><br><span class="line">            res = Math.max(res,i - l + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、动态规划</strong></p>
<p><strong>总体基本思路：</strong></p>
<p><em><img src="/2022/05/28/%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20220528212923701.png" class title="examplename"></em></p>
<p><strong>2.1 动态规划 + 哈希表</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li><strong>哈希表统计：</strong> 遍历字符串 s 时，使用哈希表（记为 dic ）统计 各字符最后一次出现的索引位置 。</li>
<li><strong>左边界 i 获取方式：</strong> 遍历到 s[j] 时，可通过访问哈希表 dic[s[j]] 获取最近的相同字符的索引 i 。</li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> 其中 N 为字符串长度，动态规划需遍历计算 dp 列表。</li>
<li><strong>空间复杂度O(∣Σ∣)：</strong>，其中 Σ 表示字符集（即字符串中可以出现的字符），∣Σ∣ 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0, 128)内的字符，即 ∣Σ∣&#x3D;128。我们需要用到哈希集合来存储出现过的字符，而字符最多有 ∣Σ∣ 个，因此空间复杂度为 O(∣Σ∣)。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划 + 哈希表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义map集合，用来存放s中字符的位置对应的索引</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// tmp是dp</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>,tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> map.getOrDefault(s.charAt(j),-<span class="number">1</span>);</span><br><span class="line">            map.put(s.charAt(j),j);</span><br><span class="line">            tmp = tmp &lt; j - i ? tmp + <span class="number">1</span> : j - i;</span><br><span class="line">            res = Math.max(res,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2.2 双指针 + 哈希表</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li><em><img src="/2022/05/28/%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20220528213320881.png" class title="examplename"></em></li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> 其中 N 为字符串长度，动态规划需遍历计算 dp 列表。</li>
<li><strong>空间复杂度O(∣Σ∣)：</strong>，其中 Σ 表示字符集（即字符串中可以出现的字符），∣Σ∣ 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0, 128)内的字符，即 ∣Σ∣&#x3D;128。我们需要用到哈希集合来存储出现过的字符，而字符最多有 ∣Σ∣ 个，因此空间复杂度为 O(∣Σ∣)。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双指针 + 哈希表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义map集合，用来存放s中字符的位置对应的索引</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// i 是左指针，j 是右指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, i = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="comment">// 如果map中已有目前右指针指向的key，</span></span><br><span class="line">            <span class="comment">// 左指针取（已有key的value和目前左指针）的最大值</span></span><br><span class="line">            <span class="comment">// ，因为如果已有key的value在左指针的左边，说明已经有重复的了，移过去再算j - i 就不对了</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s.charAt(j))) &#123;</span><br><span class="line">                i = Math.max(i,map.get(s.charAt(j)));</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(j),j);</span><br><span class="line">            res = Math.max(res,j - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2.3</strong> 可以以此为例子，做解析：</p>
<ul>
<li><em><img src="/2022/05/28/%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20220528213526540.png" class title="examplename"></em></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>树的子结构</title>
    <url>/2022/05/25/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/25/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/image-20220525141933212.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、先序遍历 + 包含判断</strong></p>
<ul>
<li><p><strong>解题思路：</strong>若树 B 是树 A 的子结构，则子结构的根节点可能为树 A 的任意一个节点。因此，判断树 B 是否是树 A 的子结构，需完成以下两步工作：</p>
<ol>
<li>先序遍历树 A 中的每个节点 nA ；（对应函数 isSubStructure(A, B)）</li>
<li>判断树 A 中 以 nA 为根节点的子树 是否包含树 B 。（对应函数 recur(A, B)）</li>
</ol>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(MN) ：</strong> 其中 M,N分别为树 A 和 树 B 的节点数量；先序遍历树 A 占用 O(M) ，每次调用 recur(A, B) 判断占用 O(N) 。</li>
<li><strong>空间复杂度 O(M) ：</strong> 当树 A 和树 B 都退化为链表时，递归调用深度最大。当 M≤N 时，遍历树 A 与递归判断的总递归深度为 M ；当 M&gt;N 时，最差情况为遍历至树 A 叶子节点，此时总递归深度为 M。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过前序遍历的深度遍历法的思想</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 先序遍历树 A 中的每个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 判断A和B是否为空，因为约定空树不是任意一个树的子结构，所以直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || B == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 根据前序遍历判断</span></span><br><span class="line">        <span class="keyword">return</span> recur(A,B) || isSubStructure(A.left,B) || isSubStructure(A.right,B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断树 A 中 以 nA 为根节点的子树 是否包含树 B</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">recur</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">        <span class="comment">// B为空了，说明B的全部结点和A的子节点全部匹配上了</span></span><br><span class="line">        <span class="keyword">if</span> (B == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// A的结点为空，B的结点不为空；或者A的结点和B的结点不同；都说明不匹配</span></span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.val != B.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 到这里说明A和B的值相等，接下来判断他们的left和right</span></span><br><span class="line">        <span class="keyword">return</span> recur(A.left,B.left) &amp;&amp; recur(A.right,B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>搜索与回溯</category>
        <category>深度优先搜索</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>用两个栈实现队列</title>
    <url>/2022/05/21/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h5 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h5><p><em><img src="/2022/05/21/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/image-20220521101300544.png" class title="examplename"></em></p>
<h5 id="题意："><a href="#题意：" class="headerlink" title="题意："></a><strong>题意：</strong></h5><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line"></span><br><span class="line">[<span class="string">&quot;CQueue&quot;</span>,<span class="string">&quot;appendTail&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>] </span><br><span class="line">这一行表示每一行代码的操作</span><br><span class="line"></span><br><span class="line">[[],[<span class="number">3</span>],[],[]]</span><br><span class="line">这个表示每一行代码操作所需要的参数</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line"><span class="symbol">CQueue</span> 表示新建一个<span class="symbol">CQueue</span>对象，对应的所需参数为[]，即此操作不需要参数。</span><br><span class="line">appendTail 表示执行一个appendTail()操作，对应要被操作的元素为<span class="number">3</span>。</span><br><span class="line">deleteHead 表示执行一个deleteHead操作，对应的所需参数为[]，即此操作不需要参数。</span><br><span class="line">deleteHead 表示执行一个deleteHead操作，对应的所需参数为[]，即此操作不需要参数。</span><br><span class="line"></span><br><span class="line">以上的输入其实是一个代码执行的步骤描述与其对应所需参数。</span><br><span class="line"></span><br><span class="line">即两个纬度：</span><br><span class="line"><span class="number">1</span>、操作描述</span><br><span class="line"><span class="number">2</span>、此次操作所需参数</span><br><span class="line"><span class="number">3</span>、操作描述与操作所需参数是通过默认顺序一一对应的。</span><br></pre></td></tr></table></figure>

<h5 id="题解："><a href="#题解：" class="headerlink" title="题解："></a><strong>题解：</strong></h5><p><strong>1、方法一：使用普通的Stack对象实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line">    <span class="type">Stack</span> <span class="variable">stack1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Stack</span> <span class="variable">stack2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (stack1.empty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">                stack2.add(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>)stack2.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>)stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、方法二：使用LinkedList双向链表来实现</strong>（优解）</p>
<p>​		如果你使用Stack的方式来做这道题，会造成速度较慢； 原因的话是Stack继承了Vector接口，而Vector底层是一个Object[]数组，那么就要考虑空间扩容和移位的问题了。 可以使用LinkedList来做Stack的容器，因为LinkedList实现了Deque接口，所以Stack能做的事LinkedList都能做，其本身结构是个双向链表，扩容消耗少。 但是我的意思不是像100%代码那样直接使用一个LinkedList当做队列，那确实是快，但是不符题意。 贴上代码，这样的优化之后，效率提高了40%，超过97%。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; stack1;</span><br><span class="line">	LinkedList&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">		stack1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">		stack2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">		stack1.add(value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (stack1.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">				stack2.add(stack1.pop());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> stack2.pop();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">return</span> stack2.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
        <category>栈与队列</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵中的路径</title>
    <url>/2022/05/31/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/31/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/image-20220531145711793.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、深度优先搜索（DFS）+ 剪枝</strong></p>
<ul>
<li><p><strong>解题思路：</strong>本问题是典型的矩阵搜索问题，可使用 <strong>深度优先搜索（DFS）+ 剪枝</strong> 解决。</p>
<ul>
<li><strong>深度优先搜索：</strong> 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</li>
<li><strong>剪枝：</strong> 在搜索中，遇到 <code>这条路不可能和目标字符串匹配成功</code> 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 <code>可行性剪枝</code> 。</li>
<li><em><img src="/2022/05/31/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/image-20220531145941693.png" class title="examplename"></em></li>
</ul>
</li>
<li><p><strong>解题中主要出现的问题：</strong></p>
<ul>
<li><p><code>board[i][j] = &#39;\0&#39;;</code></p>
<blockquote>
<p>​		使用空字符（Python: ‘’ , Java&#x2F;C++: ‘\0’ ）做标记是为了防止标记字符与矩阵原有字符重复。当存在重复时，此算法会将矩阵原有字符认作标记字符，从而出现错误。</p>
</blockquote>
</li>
<li><p><code>board[i][j] = word[k];</code></p>
<blockquote>
<p>​		递归搜索匹配字符串过程中，需要 <code>board[i][j] = &#39;\0&#39;</code> 来防止 ”走回头路“ 。当匹配字符串不成功时，会回溯返回，此时需要<code>board[i][j] = tmp</code> 来”取消对此单元格的标记”。 在DFS过程中，每个单元格会多次被访问的， <code>board[i][j] = &#39;\0&#39;</code>只是要保证在当前匹配方案中不要走回头路。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<blockquote>
<p><em>M</em>,<em>N</em> 分别为矩阵行列大小， <em>K</em> 为字符串 <code>word</code> 长度。</p>
</blockquote>
<ul>
<li><strong>时间复杂度 O(3^KMN) ：</strong> 最差情况下，需要遍历矩阵中长度为 K 字符串的所有方案，时间复杂度为 **O(3^K)**；矩阵中共有 MN 个起点，时间复杂度为 **O(MN)**。<ul>
<li><strong>方案数计算：</strong> 设字符串长度为 K ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下 3 种选择，因此方案数的复杂度为 <strong>O(3^K)</strong> 。</li>
</ul>
</li>
<li><strong>空间复杂度 O(K) ：</strong> 搜索过程中的递归深度不超过 K ，因此系统因函数调用累计使用的栈空间占用 <strong>O(K)</strong> （因为函数返回后，系统调用的栈空间会释放）。最坏情况下 <strong>K &#x3D; MN</strong> ，递归深度为 <strong>MN</strong> ，此时系统栈使用 <strong>O(MN)</strong> 的额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 深度优先搜索（DFS）+ 剪枝</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="comment">// 将String类型的word变成char数组</span></span><br><span class="line">        <span class="type">char</span>[] words = word.toCharArray();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(board,words,i,j,<span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深度优先搜索</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">char</span>[] words, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 当i，j超出边界，或矩阵中i行j列的元素不等于word第k个char，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= board.length || j &gt;= board[<span class="number">0</span>].length || board[i][j] != words[k]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 当k为最后一位，因为前面判断了board[i][j] != words[k]，所以返回true</span></span><br><span class="line">        <span class="keyword">if</span>(k == words.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 使用空字符（Python: &#x27;&#x27; , Java/C++: &#x27;\0&#x27; ）做标记是为了防止标记字符与矩阵原有字符重复。</span></span><br><span class="line">        <span class="comment">// 当存在重复时，此算法会将矩阵原有字符认作标记字符，从而出现错误。</span></span><br><span class="line">        board[i][j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，</span></span><br><span class="line">        <span class="comment">// 使用 或 连接 （代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至 res 。</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> dfs(board,words,i - <span class="number">1</span>,j,k+<span class="number">1</span>) || dfs(board,words,i ,j - <span class="number">1</span>,k+<span class="number">1</span>)</span><br><span class="line">                || dfs(board,words,i + <span class="number">1</span>,j,k+<span class="number">1</span>) || dfs(board,words,i ,j + <span class="number">1</span>,k+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归搜索匹配字符串过程中，需要 board[i][j] = &#x27;\0&#x27; 来防止 “走回头路” 。</span></span><br><span class="line">        <span class="comment">// 当匹配字符串不成功时，会回溯返回，此时需要board[i][j] = tmp 来“取消对此单元格的标记”。</span></span><br><span class="line">        <span class="comment">// 在DFS过程中，每个单元格会多次被访问的，</span></span><br><span class="line">        <span class="comment">// board[i][j] = &#x27;\0&#x27;只是要保证在当前匹配方案中不要走回头路。</span></span><br><span class="line">        board[i][j] = words[k];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>搜索与回溯</category>
        <category>回溯法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>礼物的最大价值</title>
    <url>/2022/05/27/%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/27/%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/image-20220527164053361.png" class title="examplename"></em></p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p><strong>1、动态规划</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li><em><img src="/2022/05/27/%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/image-20220527164146126.png" class title="examplename"></em></li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(MN) ：</strong> M, N 分别为矩阵行高、列宽；动态规划需遍历整个 grid 矩阵，使用 O(MN) 时间。</li>
<li><strong>空间复杂度 O(1)</strong> ： 原地修改使用常数大小的额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划，多开一行一列的空间</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//max[i][j]表示从grid[0][0]到grid[i - 1][j - 1]时的最大价值</span></span><br><span class="line">        <span class="type">int</span>[][] max = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                max[i][j] = Math.max(max[i][j - <span class="number">1</span>] ,max[i - <span class="number">1</span>][j])  + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第一个只出现一次的字符</title>
    <url>/2022/05/23/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/23/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/image-20220523213750652.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、使用哈希表存储</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li>遍历字符串 <code>s</code> ，使用哈希表统计 “各字符数量是否 &gt;1 ”。</li>
<li>再遍历字符串 <code>s</code> ，在哈希表中找到首个 “数量为 1 的字符”，并返回。</li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> N 为字符串 s 的长度；需遍历 s 两轮，使用 O(N) ；HashMap 查找操作的复杂度为 O(1)；</li>
<li><strong>空间复杂度 O(1) ：</strong> 由于题目指出 s 只包含小写字母，因此最多有 26 个不同字符，HashMap 存储需占用 O(26) &#x3D; O(1) 的额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        HashMap&lt;Character, Boolean&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] array = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:</span><br><span class="line">             array) &#123;</span><br><span class="line">            <span class="comment">// 如果遇到重复的，value变为false</span></span><br><span class="line">            map.put(c,!map.containsKey(c));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在map中查找第一个为true的</span></span><br><span class="line">        <span class="comment">// 因为hashMap是乱序的，不能直接通过map查找到第一个，而是通过array原来的顺序，进行map查找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:</span><br><span class="line">             array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(c)) &#123;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、有序哈希表</strong></p>
<p>在字符串长度较大、重复字符很多时，“有序哈希表” 解法理论上效率更高。</p>
<p>解题思路和时间复杂度一样。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有序哈希表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;Character, Boolean&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : sc)</span><br><span class="line">            map.put(c, !map.containsKey(c));</span><br><span class="line">        <span class="comment">// Map的entrySet()方法返回一个实现Map.Entry接口的对象集合。Map.Entry里面包含getKey()和getValue()方法,entrySet实现了Set接口，里面存放的是键值对。一个K对应一个V。</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Character, Boolean&gt; d : map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(d.getValue()) <span class="keyword">return</span> d.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
        <category>查找算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转单词顺序</title>
    <url>/2022/05/30/%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/30/%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/image-20220530194231003.png" class title="examplename"></em></p>
<h4 id="解题："><a href="#解题：" class="headerlink" title="解题："></a>解题：</h4><p><strong>1、双指针</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li>倒序遍历字符串 s ，记录单词左右索引边界 i , j ；</li>
<li>每确定一个单词的边界，则将其添加至单词列表 res ；</li>
<li>最终，将单词列表拼接为字符串，并返回即可。</li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> 其中 N 为字符串 s 的长度，线性遍历字符串。</li>
<li><strong>空间复杂度 O(N) ：</strong> 新建的 StringBuilder 中的字符串总长度 ≤N ，占用 O(N) 大小的额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 删除首尾空格</span></span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> j;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 让i走到首个空格</span></span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) != <span class="string">&#x27; &#x27;</span>) i--;</span><br><span class="line">            <span class="comment">// 添加单词</span></span><br><span class="line">            res.append(s.substring(i+<span class="number">1</span>,j+<span class="number">1</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">// 跳过单词间的空格</span></span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27; &#x27;</span>) i--;</span><br><span class="line">            <span class="comment">// j 指向下个单词的尾字符</span></span><br><span class="line">            j = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 消除最后多余的一个的空格</span></span><br><span class="line">        <span class="keyword">return</span> res.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、分割 + 倒序</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li><em><img src="/2022/05/30/%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/image-20220530194745752.png" class title="examplename"></em></li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N)</strong></li>
</ul>
</li>
<li><p><strong>空间复杂度 O(N) ：</strong> 单词列表 strs 占用线性大小的额外空间。</p>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分割 + 倒序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 删除首尾空格，分割字符串</span></span><br><span class="line">        String[] strs = s.trim().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">// 拼接时所需</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> strs.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[i].equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            res.append(strs[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 消除最后多余的一个的空格</span></span><br><span class="line">        <span class="keyword">return</span> res.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>双指针</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>股票的最大利润</title>
    <url>/2022/05/26/%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/26/%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/image-20220526204147040.png" class title="examplename"></em></p>
<p><strong>基本题意：找到差值最大的返回差值</strong></p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p><strong>1、暴力法</strong></p>
<ul>
<li><p><strong>解题思路：</strong>暴力双层遍历找到差值最大的返回差值</p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度O(n^2)：</strong>双层循环</li>
<li><strong>空间复杂度O(1)</strong></li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴力遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 暴力找到差值最大的返回差值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((prices[j] - prices[i]) &gt; max )&#123;</span><br><span class="line">                    max = prices[j] - prices[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、一次遍历（动态规划法）</strong></p>
<ul>
<li><p><strong>解题思路：</strong>前 i 日最大利润&#x3D;max(前 (i−1) 日最大利润,第 i 日价格 − 前 i 日最低价格)</p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> 其中 N 为 prices 列表长度，动态规划需遍历 prices 。</li>
<li><strong>空间复杂度 O(1) ：</strong> 变量 min和 max 使用常数大小的额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一次遍历，动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 一步一步进行，判断如果该值小于最小值，就成为最小值，否则，判断该值与最小值只差是否大于目前差值最大值，大于就将差值付给他</span></span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; min) &#123;</span><br><span class="line">                min = prices[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (prices[i] - min &gt; max) &#123;</span><br><span class="line">                max = prices[i] - min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优化代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> price : prices) &#123;</span><br><span class="line">            <span class="comment">// 一步一步进行，判断如果该值小于最小值，就成为最小值，否则，判断该值与最小值只差是否大于目前差值最大值，大于就将差值付给他</span></span><br><span class="line">            min = Math.min(min,price);</span><br><span class="line">            max = Math.max(max,price - min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计算特殊奖金</title>
    <url>/2022/05/29/%E8%AE%A1%E7%AE%97%E7%89%B9%E6%AE%8A%E5%A5%96%E9%87%91/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/29/%E8%AE%A1%E7%AE%97%E7%89%B9%E6%AE%8A%E5%A5%96%E9%87%91/image-20220529211730079.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><h5 id="sql语句case-when用法详解"><a href="#sql语句case-when用法详解" class="headerlink" title="sql语句case when用法详解"></a>sql语句case when用法详解</h5><p>类似于witch case，</p>
<p><strong>第一种 格式 : 简单Case函数 :</strong></p>
<p>格式说明</p>
<blockquote>
<p>　　　　case 列名</p>
<p>　　　　when 条件值1 then 选择项1</p>
<p>　　　　when 条件值2 then 选项2…….</p>
<p>　　　　else 默认值 end</p>
</blockquote>
<p><strong>第二种 格式 :Case搜索函数</strong></p>
<p>格式说明</p>
<blockquote>
<p>　　　　case</p>
<p>　　　　when 列名&#x3D; 条件值1 then 选择项1</p>
<p>　　　　when 列名&#x3D;条件值2 then 选项2…….</p>
<p>　　　　else 默认值 end</p>
</blockquote>
<ul>
<li><p>sql语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> e.employee_id,</span><br><span class="line"><span class="keyword">CASE</span> </span><br><span class="line"><span class="keyword">WHEN</span> </span><br><span class="line">    <span class="built_in">MOD</span>(e.employee_id,<span class="number">2</span>) <span class="operator">=</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> e.name <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">&#x27;M%&#x27;</span> </span><br><span class="line"><span class="keyword">then</span> e.salary <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span> <span class="keyword">as</span> bonus</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	Employees <span class="keyword">as</span> e</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> </span><br><span class="line">    e.employee_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>基础</category>
        <category>mysql</category>
        <category>SQL入门</category>
        <category>排序 &amp; 修改</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>SQL入门</tag>
      </tags>
  </entry>
  <entry>
    <title>认证与授权实现思路</title>
    <url>/2022/04/24/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="认证与授权实现思路"><a href="#认证与授权实现思路" class="headerlink" title="认证与授权实现思路"></a>认证与授权实现思路</h2><p>Spring Security其实就是用<strong>filter</strong>，多请求的路径进行过滤。</p>
<span id="more"></span>

<p>​	如果系统的模块众多，每个模块都需要就行授权与认证，所以我们选择基于token的形式进行授权与认 证，用户根据用户名密码认证成功，然后获取当前用户角色的一系列权限值，并以用户名为key，权限列 表为value的形式存入redis缓存中，根据用户名相关信息生成token返回，浏览器将token记录到cookie中， 每次调用api接口都默认将token携带到header请求头中，Spring-security解析header头获取token信息，解 析token获取当前用户名，根据用户名就可以从redis中获取权限列表，这样Spring-security就能够判断当前 请求是否有权限访问</p>
<p><em><img src="/2022/04/24/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/image-20220424191422878.png" class title="examplename"></em></p>
]]></content>
      <categories>
        <category>面试</category>
        <category>面试题</category>
        <category>权限</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>面试</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title>连续子数组的最大和</title>
    <url>/2022/05/27/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/27/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/image-20220527105249989.png" class title="examplename"></em></p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p><strong>1、前缀和算法</strong></p>
<ul>
<li><p><strong>解题思路：</strong>所有 当前的前缀和 - 前面出现过的最小前缀和 的最大值（当前的前缀和去掉之前最小的前缀和，反而会变大，相当于之前的是累赘）</p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度O(n)</strong></li>
<li><strong>空间复杂度O(1)</strong></li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前缀和算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxNums</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            maxNums += nums[i];</span><br><span class="line">            <span class="comment">// 所有 当前的前缀和 - 前面出现过的最小前缀和 的最大值</span></span><br><span class="line">            <span class="comment">// 当前的前缀和去掉之前最小的前缀和，反而会变大，相当于之前的是累赘</span></span><br><span class="line">            max = Math.max(max,maxNums - min);</span><br><span class="line">            min = Math.min(min,maxNums);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、动态规划法</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li>第i+1个数，前i个数之和如果是正数，那么第i+1个数加上前i个数就会变大；如果是负数，则反转，那么前i+1个数就是nums[i+1]</li>
<li><em><img src="/2022/05/27/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/image-20220527105545361.png" class title="examplename"></em></li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度O(n)</strong></li>
<li><strong>空间复杂度O(n)：</strong>状态数组的长度为N</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i]= Math.max(dp[i-<span class="number">1</span>] + nums[i],nums[i]);</span><br><span class="line">            max = Math.max(max,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>滚动变量优化</strong></p>
<ul>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度O(n)</strong></li>
<li><strong>空间复杂度O(1)</strong></li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划法(滚动变量优化）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            dp = Math.max(dp + num,num);</span><br><span class="line">            max = Math.max(max,dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>调整数组顺序使奇数位于偶数前面</title>
    <url>/2022/05/30/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/30/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/image-20220530084144683.png" class title="examplename"></em></p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p><strong>1、使用list组合算法（差劲）</strong></p>
<ul>
<li><p><strong>解题思路：</strong>将奇数放在一个list，偶数放在一个list，最后合并，并转换为数组返回。</p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N)  ：</strong>  <em>N</em> 为数组 nums 长度。</li>
<li><strong>空间复杂度 O(N)  ：</strong>  <em>N</em> 为数组 nums 长度。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用list组合算法（差劲）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] exchange(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; b = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                a.add(num);</span><br><span class="line">            &#125;<span class="keyword">else</span> b.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        c.addAll(a);</span><br><span class="line">        c.addAll(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组变list Arrays.stream(new String[]&#123;&quot;Mai&quot;, &quot;Jelly&quot;&#125;).collect(Collectors.toList());</span></span><br><span class="line">        <span class="comment">/* JDK1.8引⼊了Stream流概念可以把List转换成stream流，调⽤</span></span><br><span class="line"><span class="comment">        mapToInt⽅法将Integer对象转换成int类型，再调⽤toArray⽅法转换成数组。*/</span></span><br><span class="line">        <span class="keyword">return</span> c.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、双指针</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ol>
<li>指针 <em>i</em> 从左向右寻找偶数；</li>
<li>指针 <em>j</em> 从右向左寻找奇数；</li>
<li>将 偶数 nums[i] 和 奇数 nums[j] 交换。</li>
</ol>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N)  ：</strong>  <em>N</em> 为数组 nums 长度，双指针 <em>i</em>, <em>j</em> 共同遍历整个数组。</li>
<li><strong>空间复杂度 O(1)  ：</strong>  双指针 <em>i</em>, <em>j</em> 使用常数大小的额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] exchange(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = nums.length -<span class="number">1</span>, tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; (nums[i] % <span class="number">2</span>) == <span class="number">1</span>) i++;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; (nums[j] % <span class="number">2</span>) == <span class="number">0</span>) j--;</span><br><span class="line">            tmp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>双指针</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>链表中倒数第k个节点</title>
    <url>/2022/05/29/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/29/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/image-20220529102734918.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、双指针</strong></p>
<ul>
<li><p><strong>解题思路：</strong>设置俩个指针，一个指向头节点pre，一个指向pre之后的距离k-1的节点cur，（因为两个遍历到cur.next为null时，也就是cur到了最后，pre正好是倒数第k个节点）返回pre即可。</p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度O(n)：</strong> <em>N</em> 为链表长度；总体看N-1，循环1走了k-1，循环2走了N-k</li>
<li><strong>空间复杂度O(1)</strong></li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="comment">// 设置俩个指针，一个指向头节点pre，一个指向pre之后的距离k-1的节点cur，（因为两个遍历到cur.next为null时，也就是cur到了最后，pre正好是倒数第k个节点）返回pre即可。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 遍历使得cur指向pre（目前是head）之后的距离k-1的节点，当中如果有空，说明倒数第k个节点是不存在的，直接返回null</span></span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>只需要一个循环的代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个循环</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        ListNode slow=head,fast=head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t&gt;=k) slow=slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>双指针</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>青蛙跳台阶问题</title>
    <url>/2022/05/26/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/26/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/image-20220526161257604.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、动态规划</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li>设跳上 n 级台阶有 f(n) 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： <strong>跳上 1 级或 2 级台阶</strong>。<ul>
<li>当为 1 级台阶： 剩 n-1 个台阶，此情况共有 f(n-1) 种跳法；</li>
<li>当为 2 级台阶： 剩 n-2 个台阶，此情况共有 f(n-2) 种跳法。</li>
</ul>
</li>
<li>f(n) 为以上两种情况之和，即 f(n)&#x3D;f(n-1)+f(n-2)，以上递推性质为斐波那契数列。本题可转化为 求斐波那契数列第 n 项的值 ，与  <a href="https://nuc462.github.io/2022/05/26/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/">斐波那契数列 - 轩辕&amp;小站</a> 等价，唯一的不同在于起始数字不同。<ul>
<li>青蛙跳台阶问题： f(0)&#x3D;1 , f(1)&#x3D;1 , f(2)&#x3D;2 ；</li>
<li>斐波那契数列问题： f(0)&#x3D;0 , f(1)&#x3D;1 , f(2)&#x3D;1 。</li>
<li><em><img src="/2022/05/26/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/image-20220526162545313.png" class title="examplename"></em></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> 计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1)。</li>
<li><strong>空间复杂度 O(1) ：</strong> 几个标志变量使用常数大小的额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 记录每次的a+b，避免重复计算</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum = (a+b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>机器人的运动范围</title>
    <url>/2022/06/01/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/06/01/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/image-20220601090921691.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>解题所需前提：</strong></p>
<p><em><img src="/2022/06/01/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/image-20220601091323608.png" class title="examplename"></em></p>
<p><strong>1、深度优先遍历</strong></p>
<ul>
<li><p><strong>解题思路：</strong>本问题是典型的矩阵搜索问题，可使用 <strong>深度优先搜索（DFS）+ 剪枝</strong> 解决。</p>
<ul>
<li><strong>深度优先搜索：</strong> 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</li>
<li><strong>剪枝：</strong> 在搜索中，遇到 <code>这条路不可能和目标字符串匹配成功</code> 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 <code>可行性剪枝</code> 。</li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<blockquote>
<p>设矩阵行列数分别为 M, N 。</p>
</blockquote>
<p><strong>时间复杂度 O(MN) ：</strong> 最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为 O(MN) 。<br><strong>空间复杂度 O(MN) ：</strong> 最差情况下，visited 内存储矩阵所有单元格的索引，使用 O(MN) 的额外空间。</p>
</li>
<li><p><strong>代码：</strong></p>
<ul>
<li><p><strong>普通版（未使用位数和规则）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 深度优先遍历，普通</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否重复</span></span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,m,n,k,visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k, <span class="type">boolean</span>[][] visited)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt;= <span class="number">0</span> &amp;&amp; a &lt; m &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; n</span><br><span class="line">                &amp;&amp; (a % <span class="number">10</span> + a / <span class="number">10</span> + a / <span class="number">100</span> + b % <span class="number">10</span> + b / <span class="number">10</span> + b / <span class="number">100</span>) &lt;= k</span><br><span class="line">                &amp;&amp; visited[a][b] == <span class="literal">false</span>) &#123;</span><br><span class="line">            visited[a][b] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 1是(0,0)位置，只需递归他右面和下面的即可</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + dfs(a + <span class="number">1</span>, b, m, n, k, visited) + dfs(a, b + <span class="number">1</span>, m, n, k, visited);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>复杂版（使用位数和规则）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 深度优先遍历，复杂（找到位数和的规律，不需要每次计算，直接递归即可），第一种的优化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="type">int</span> m, n, k;</span><br><span class="line">    <span class="type">boolean</span>[][] visited;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.m = m; <span class="built_in">this</span>.n = n; <span class="built_in">this</span>.k = k;</span><br><span class="line">        <span class="built_in">this</span>.visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前元素在矩阵中的行列索引 i 和 j ，两者的数位和 si, sj</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> si, <span class="type">int</span> sj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || j &gt;= n || k &lt; si + sj || visited[i][j]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j, (i + <span class="number">1</span>) % <span class="number">10</span> != <span class="number">0</span> ? si + <span class="number">1</span> : si - <span class="number">8</span>, sj) + dfs(i, j + <span class="number">1</span>, si, (j + <span class="number">1</span>) % <span class="number">10</span> != <span class="number">0</span> ? sj + <span class="number">1</span> : sj - <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>2、广度优先遍历</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
</li>
<li><p><em><img src="/2022/06/01/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/image-20220601091942449.png" class title="examplename"></em></p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<blockquote>
<p>设矩阵行列数分别为 M, N 。</p>
</blockquote>
<p><strong>时间复杂度 O(MN) ：</strong> 最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为 O(MN) 。<br><strong>空间复杂度 O(MN) ：</strong> 最差情况下，visited 内存储矩阵所有单元格的索引，使用 O(MN) 的额外空间。</p>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 广度优先遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span>[] poll = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> poll[<span class="number">0</span>],j = poll[<span class="number">1</span>],si = poll[<span class="number">2</span>],sj = poll[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= m || j &gt;= n || si + sj &gt; k || visited[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">            count++;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;i + <span class="number">1</span>,j,(i + <span class="number">1</span>) % <span class="number">10</span> != <span class="number">0</span> ? si + <span class="number">1</span> : si - <span class="number">8</span>, sj&#125;);</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;i ,j + <span class="number">1</span>, si, (j + <span class="number">1</span>) % <span class="number">10</span> != <span class="number">0</span> ? sj + <span class="number">1</span> : sj - <span class="number">8</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>搜索与回溯</category>
        <category>回溯法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树中和为某一值的路径</title>
    <url>/2022/06/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/06/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/image-20220601162606712.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、回溯法</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li><strong>先序遍历：</strong> 按照 “根、左、右” 的顺序，遍历树的所有节点。</li>
<li><strong>路径记录：</strong> 在先序遍历中，记录从根节点到当前节点的路径。当路径为 ① 根节点到叶节点形成的路径 <strong>且</strong> ② 各节点值的和等于目标值 sum 时，将此路径加入结果列表。</li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> N 为二叉树的节点数，先序遍历需要遍历所有节点。</li>
<li><strong>空间复杂度 O(N) ：</strong> 最差情况下，即树退化为链表时，path 存储所有树节点，使用 O(N) 额外空间。</li>
</ul>
</li>
<li><p><strong>值得注意的是，</strong>记录路径时若直接执行 <code>res.add(path)</code> ，则是将 <code>path</code> 对象加入了 <code>res</code> ；后续 <code>path</code> 改变时， <code>res</code> 中的 <code>path</code> 对象也会随之改变。</p>
<p>正确做法：<code>res.add(new LinkedList(path))</code> ，相当于复制了一个 <code>path</code> 并加入到 <code>res</code> 。</p>
<ul>
<li><strong>深拷贝：</strong>开辟一个独立地址，地址中存放的内容为list链表，后续list的变化不会影响到res。</li>
<li><strong>浅拷贝：</strong>将res尾部指向了list地址，后续list内容的变化会导致res的变化，所以res输出为空。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化返回的list</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录返回路径</span></span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        dfs(root,target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先序遍历 + 路径记录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将root的值存入路径集合中</span></span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="comment">// target减去此时指针的值</span></span><br><span class="line">        target -= root.val;</span><br><span class="line">        <span class="comment">// 判断，如果target = 0，并且还是叶子节点，则说明这条路径是走完了，且是符合条件的路径，则将path赋给res</span></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left,target);</span><br><span class="line">        dfs(root.right,target);</span><br><span class="line">        path.removeLast();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>搜索与回溯</category>
        <category>深度优先搜索</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树与双向链表</title>
    <url>/2022/06/01/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/06/01/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/image-20220601211205938.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、中序遍历</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li><em><img src="/2022/06/01/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/image-20220601211311107.png" class title="examplename"></em></li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> N 为二叉树的节点数，中序遍历需要访问所有节点。</li>
<li><strong>空间复杂度 O(N) ：</strong> 最差情况下，即树退化为链表时，递归深度达到 N，系统使用 O(N) 栈空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> _val)</span> &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> _val,Node _left,Node _right)</span> &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        left = _left;</span><br><span class="line">        right = _right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// pre前驱节点，head头节点</span></span><br><span class="line">    Node pre, head;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">treeToDoublyList</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里必须判断，否则会报错，因为head是null，没有left</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 中序遍历，并将除了首尾节点循环双连接的其余节点进行双连接</span></span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="comment">// 使得首尾节点循环双连接</span></span><br><span class="line">        head.left = pre;</span><br><span class="line">        pre.right = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回头节点即可</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Node cur)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(cur.left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span>) &#123;</span><br><span class="line">            pre.right = cur;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> head = cur;</span><br><span class="line"></span><br><span class="line">        cur.left = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line"></span><br><span class="line">        dfs(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>搜索与回溯</category>
        <category>深度优先搜索</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树的第k大节点</title>
    <url>/2022/06/01/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/06/01/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/image-20220601215320446.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、中序遍历（倒序）</strong></p>
<ul>
<li><p><strong>解题思路：</strong>中序遍历倒序，存入list，数量等于k时返回；优化是使用k–，即可。</p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N)) ：</strong> 当树退化为链表时（全部为右子节点），无论 k 的值大小，递归深度都为 N ，占用 O(N) 时间。</li>
<li><strong>空间复杂度 O(N) ：</strong> 当树退化为链表时（全部为右子节点），系统使用 O(N) 大小的栈空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthLargest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">if</span> (list.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode cur)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(cur.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="keyword">if</span> (a == k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(cur.val);</span><br><span class="line">        dfs(cur.left);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优化：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="type">int</span> res, k;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthLargest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">        <span class="comment">// 当k == 0 时，不用再继续遍历了，节省时间和空间</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(--k == <span class="number">0</span>) res = root.val;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>搜索与回溯</category>
        <category>深度优先搜索</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>把数组排成最小的数</title>
    <url>/2022/06/02/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/06/02/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/image-20220602170029801.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>解题思路：</strong></p>
<ul>
<li><p>若拼接字符串 x + y &gt; y + x ，则 x “大于” y ；</p>
</li>
<li><p>反之，若 x + y &lt; y + x ，则 x “小于” y ；</p>
</li>
<li><p><em><img src="/2022/06/02/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/image-20220602170138877.png" class title="examplename"></em></p>
</li>
</ul>
<p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(NlogN) ：</strong> N 为最终返回值的字符数量（ strs 列表的长度 ≤N ）；使用快排或内置函数的平均时间复杂度为 O(NlogN) ，最差为 O(N^2)。</li>
<li><strong>空间复杂度 O(N)</strong> ： 字符串列表 strs 占用线性大小的额外空间。</li>
</ul>
<p><strong>1、快速排序</strong></p>
<ul>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、将int数组转变为字符串数组</span></span><br><span class="line">        String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用快速排序将strs进行此题的规律排序（从“小”到“大”）</span></span><br><span class="line">        quickSort(strs,<span class="number">0</span>,strs.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、将排完序的数组以字符串的方式返回</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">            res.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(String[] strs, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 若拼接字符串 x + y &gt; y + x ，则 x “大于” y ；</span></span><br><span class="line"><span class="comment">              反之，若 x + y &lt; y + x ，则 x “小于” y ；</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            <span class="comment">// 判断当strs[j]“大于等于”strs[l]，j--</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; (strs[j] + strs[l]).compareTo(strs[l] + strs[j]) &gt;= <span class="number">0</span>) j--;</span><br><span class="line">            <span class="comment">// 判断当strs[i]“小于等于”strs[l]，i++</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; (strs[i] + strs[l]).compareTo(strs[l] + strs[i]) &lt;= <span class="number">0</span>) i++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果i = j，交换i 和 l</span></span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> strs[i];</span><br><span class="line">                strs[i] = strs[l];</span><br><span class="line">                strs[l] = tmp;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 否则交换i 和 j，交换后，strs[j]就大于strs[l]，strs[i]就小于strs[l]</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> strs[i];</span><br><span class="line">                strs[i] = strs[j];</span><br><span class="line">                strs[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        quickSort(strs,l,i-<span class="number">1</span>);</span><br><span class="line">        quickSort(strs,i+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优化后代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序优化，将i = j放到了外面，减少了每次循环的判断</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        quickSort(strs, <span class="number">0</span>, strs.length - <span class="number">1</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(String s : strs)</span><br><span class="line">            res.append(s);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(String[] strs, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = r;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> strs[i];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span>((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) j--;</span><br><span class="line">            <span class="keyword">while</span>((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) &lt;= <span class="number">0</span> &amp;&amp; i &lt; j) i++;</span><br><span class="line">            tmp = strs[i];</span><br><span class="line">            strs[i] = strs[j];</span><br><span class="line">            strs[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        strs[i] = strs[l];</span><br><span class="line">        strs[l] = tmp;</span><br><span class="line">        quickSort(strs, l, i - <span class="number">1</span>);</span><br><span class="line">        quickSort(strs, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、内置函数</strong></p>
<ul>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内置函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        Arrays.sort(strs, (x, y) -&gt; (x + y).compareTo(y + x));</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(String s : strs)</span><br><span class="line">            res.append(s);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>扑克牌中的顺子</title>
    <url>/2022/06/02/%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/06/02/%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/image-20220602204500718.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>解题思路：</strong></p>
<p>根据题意，此 5 张牌是顺子的 <strong>充分条件</strong> 如下：</p>
<ol>
<li><p>除大小王外，所有牌 <strong>无重复</strong> ；</p>
</li>
<li><p>设此 55 张牌中最大的牌为 max ，最小的牌为 min （大小王除外），则需满足：</p>
<p>​															<strong>max - min &lt; 5</strong></p>
</li>
</ol>
<p><strong>1、排序 + 遍历</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li><strong>先对数组执行排序。</strong></li>
<li><strong>判别重复：</strong> 排序数组中的相同元素位置相邻，因此可通过遍历数组，判断 nums[i] &#x3D; nums[i + 1] 是否成立来判重。</li>
<li><strong>获取最大 &#x2F; 最小的牌：</strong> 排序后，数组末位元素 nums[4] 为最大牌；元素 nums[joker] 为最小牌，其中 joker 为大小王的数量。</li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(NlogN)&#x3D;O(5log5)&#x3D;O(1) ：</strong> 其中 N 为 nums 长度，本题中 N≡5 ；数组排序使用 O(NlogN) 时间。</li>
<li><strong>空间复杂度 O(1)：</strong> 变量 joker 使用 O(1) 大小的额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 排序 + 遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStraight</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 先将数组进行排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// 记录大小王数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">joker</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                joker++; <span class="comment">// 统计大小王数量</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i + <span class="number">1</span>] == nums[i]) &#123; <span class="comment">// 若有重复，提前返回 false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最大牌 - 最小牌 &lt; 5 则可构成顺子</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">4</span>] - nums[joker] &lt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、集合 Set + 遍历</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li><strong>遍历五张牌，遇到大小王（即 0 ）直接跳过。</strong></li>
<li><strong>判别重复：</strong> 利用 Set 实现遍历判重， Set 的查找方法的时间复杂度为 O(1) ；</li>
<li><strong>获取最大 &#x2F; 最小的牌：</strong> 借助辅助变量 max 和 min ，遍历统计即可。</li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) &#x3D; O(5) &#x3D; O(1) ：</strong> 其中 N 为 nums 长度，本题中 N≡5 ；遍历数组使用 O(N) 时间。</li>
<li><strong>空间复杂度 O(N) &#x3D; O(5) &#x3D; O(1) ：</strong> 用于判重的辅助 Set 使用 O(N) 额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 集合 Set + 遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStraight</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span> ,min = <span class="number">14</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            max = Math.max(max,num);</span><br><span class="line">            min = Math.min(min,num);</span><br><span class="line">            <span class="keyword">if</span> (set.contains(num)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max - min &lt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最小的k个数</title>
    <url>/2022/06/03/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/06/03/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/image-20220603151633142.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、快速排序</strong></p>
<ul>
<li><p><strong>解题思路：</strong>对原数组从小到大排序后取出前 <em>k</em> 个数即可。</p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(NlogN) ：</strong> 库函数、快排等排序算法的平均时间复杂度为 O(NlogN) 。</li>
<li><strong>空间复杂度 O(N) ：</strong> 快速排序的递归深度最好（平均）为 O(logN) ，最差情况（即输入数组完全倒序）为 O(N)。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getLeastNumbers(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(arr, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l,j = r;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= arr[l] ) j--;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= arr[l] ) i++;</span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr,i,l);</span><br><span class="line">        quickSort(arr,l,i-<span class="number">1</span>);</span><br><span class="line">        quickSort(arr,i+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、基于快速排序的数组划分</strong></p>
<ul>
<li><p><strong>解题思路：</strong>题目只要求返回最小的 k 个数，对这 k 个数的顺序并没有要求。因此，只需要将数组划分为 最小的 k 个数 和 其他数字 两部分即可，而快速排序的哨兵划分可完成此目标。</p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<blockquote>
<p>本方法优化时间复杂度的本质是通过判断舍去了不必要的递归（哨兵划分）。</p>
</blockquote>
<p><em><img src="/2022/06/03/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/image-20220603153020740.png" class title="examplename"></em></p>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序优化版</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getLeastNumbers(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= arr.length) <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="keyword">return</span> quickSort(arr, k-<span class="number">1</span>, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] quickSort(<span class="type">int</span>[] arr, <span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = r;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= arr[l]) j--;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= arr[l]) i++;</span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, l);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; k) <span class="keyword">return</span> quickSort(arr, k, l, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; k) <span class="keyword">return</span> quickSort(arr, k, i + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(arr, k+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大排序算法</title>
    <url>/2022/06/03/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h2 id="1、堆排序"><a href="#1、堆排序" class="headerlink" title="1、堆排序"></a>1、堆排序</h2><h3 id="1-1-堆的定义"><a href="#1-1-堆的定义" class="headerlink" title="1.1 堆的定义"></a>1.1 堆的定义</h3><p><em><img src="/2022/06/03/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220603170515407.png" class title="examplename"></em></p>
<h3 id="1-2-堆排序的思路（大顶堆）"><a href="#1-2-堆排序的思路（大顶堆）" class="headerlink" title="1.2 堆排序的思路（大顶堆）"></a>1.2 堆排序的思路（大顶堆）</h3><p>（1）根据初始数组去<strong>构建初始堆</strong>。</p>
<p>（2）<strong>每次交换第一个和最后一个元素，输出最后一个元素（最大值）</strong>，然后把剩下元素重新调整为大顶堆，再进行交换第一个元素和最后一个元素，再调整大顶堆，重复执行，直到整个数组排序完成。</p>
<h4 id="1-2-1-建堆的过程："><a href="#1-2-1-建堆的过程：" class="headerlink" title="1.2.1 建堆的过程："></a>1.2.1 建堆的过程：</h4><p><em><img src="/2022/06/03/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220603171200019.png" class title="examplename"></em></p>
<p><em><img src="/2022/06/03/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220603171230262.png" class title="examplename"></em></p>
<h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><ul>
<li><strong>初始建堆</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.初始建堆</span></span><br><span class="line"><span class="comment">// 从最后一个非叶子节点开始，到根节点结束</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length/<span class="number">2</span> -<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 左右孩子如果比i大，交换</span></span><br><span class="line">    heapify(arr,i,arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>左右孩子如果比i大，交换</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 左右孩子如果比i大，交换</span></span><br><span class="line"><span class="comment">// 其中last_index是用来判断i节点是否有左右孩子，因为是完全二叉树</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> last_index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="comment">// 如果i的左右孩子存在的话，因为是完全二叉树，它的左右孩子节点索引一定小于等于最后一个节点的索引</span></span><br><span class="line">    <span class="comment">// 判断i的左孩子是否大于它</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">2</span>*i+<span class="number">1</span>) &lt;= last_index &amp;&amp; arr[<span class="number">2</span>*i+<span class="number">1</span>] &gt; arr[max]) &#123;</span><br><span class="line">        max = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断i的右孩子是否大于它</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">2</span>*i+<span class="number">2</span>) &lt;= last_index &amp;&amp; arr[<span class="number">2</span>*i+<span class="number">2</span>] &gt; arr[max]) &#123;</span><br><span class="line">        max = <span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果max不是i，说明他的孩子节点有比他大，将i和max交换</span></span><br><span class="line">    <span class="keyword">if</span> (max != i) &#123;</span><br><span class="line">        swap(arr,i,max);</span><br><span class="line">        heapify(arr,max,last_index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-2-2-堆排序的过程："><a href="#1-2-2-堆排序的过程：" class="headerlink" title="1.2.2 堆排序的过程："></a>1.2.2 堆排序的过程：</h4><p><em><img src="/2022/06/03/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220603183739401.png" class title="examplename"></em></p>
<p><em><img src="/2022/06/03/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220603184043920.png" class title="examplename"></em></p>
<p><em><img src="/2022/06/03/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220603184129951.png" class title="examplename"></em></p>
<h5 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.堆排序的过程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 交换当前节点和堆顶节点</span></span><br><span class="line">    swap(arr,i,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 只需判断头节点，使得该树再次变为大顶堆</span></span><br><span class="line">    heapify(arr,<span class="number">0</span>,i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>完整代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Test</span></span><br><span class="line">    <span class="comment">// public void test() &#123;</span></span><br><span class="line">        <span class="comment">// int[] arr = &#123;27,46,12,33,49,27,36,40,42,50,51&#125;;</span></span><br><span class="line">        <span class="comment">// heapSort(arr);</span></span><br><span class="line">        <span class="comment">// System.out.println(Arrays.toString(arr));</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.初始建堆</span></span><br><span class="line">        <span class="comment">// 从最后一个非叶子节点开始，到根节点结束</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length/<span class="number">2</span> -<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 左右孩子如果比i大，交换</span></span><br><span class="line">            heapify(arr,i,arr.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.堆排序的过程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 交换当前节点和堆顶节点</span></span><br><span class="line">            swap(arr,i,<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 只需判断头节点，使得该树再次变为大顶堆</span></span><br><span class="line">            heapify(arr,<span class="number">0</span>,i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右孩子如果比i大，交换</span></span><br><span class="line">    <span class="comment">// 其中last_index是用来判断i节点是否有左右孩子，因为是完全二叉树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> last_index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="comment">// 如果i的左右孩子存在的话，因为是完全二叉树，它的左右孩子节点索引一定小于等于最后一个节点的索引</span></span><br><span class="line">        <span class="comment">// 判断i的左孩子是否大于它</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">2</span>*i+<span class="number">1</span>) &lt;= last_index &amp;&amp; arr[<span class="number">2</span>*i+<span class="number">1</span>] &gt; arr[max]) &#123;</span><br><span class="line">            max = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断i的右孩子是否大于它</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">2</span>*i+<span class="number">2</span>) &lt;= last_index &amp;&amp; arr[<span class="number">2</span>*i+<span class="number">2</span>] &gt; arr[max]) &#123;</span><br><span class="line">            max = <span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果max不是i，说明他的孩子节点有比他大，将i和max交换</span></span><br><span class="line">        <span class="keyword">if</span> (max != i) &#123;</span><br><span class="line">            swap(arr,i,max);</span><br><span class="line">            heapify(arr,max,last_index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-算法稳定性-不稳定"><a href="#1-3-算法稳定性-不稳定" class="headerlink" title="1.3 算法稳定性(不稳定)"></a>1.3 算法稳定性(不稳定)</h3><p>​		在建立堆的调整步骤里,由于关键字相同的两个记录位置并不会被调换,所以<strong>建堆</strong>的时候是<strong>稳定的</strong>。但是,在堆顶与堆尾交换的时候<strong>两个相等</strong>的记录在例中的<strong>相对位置</strong>就可能发生改变,这就影响其<strong>稳定性</strong>了。</p>
<h3 id="1-4-时间复杂度"><a href="#1-4-时间复杂度" class="headerlink" title="1.4 时间复杂度"></a>1.4 时间复杂度</h3><p>​		堆排序包括两个阶段,<strong>初始化建堆</strong>和<strong>重建堆</strong>。所以堆排序的时间复杂度由这两方面组成。<br>​		<strong>初始化建堆</strong>的时间复杂度为<strong>O(n)</strong> ,排序重建堆的时间复杂度为<strong>O(nlogn)</strong> ,所以<strong>总</strong>的时间复杂度为O(n+nlogn)&#x3D;**O(nlogn)**。</p>
<h2 id="2、冒泡排序"><a href="#2、冒泡排序" class="headerlink" title="2、冒泡排序"></a>2、冒泡排序</h2><h3 id="2-1-思路"><a href="#2-1-思路" class="headerlink" title="2.1 思路"></a>2.1 思路</h3><p><em><img src="/2022/06/03/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220608151520784.png" class title="examplename"></em></p>
<p><em><img src="/2022/06/03/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220608152244677.png" class title="examplename"></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bubbling</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">67</span>,<span class="number">42</span>,<span class="number">88</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="comment">// 外层循环控制趟数，趟数是5趟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 内层控制比较的次数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="comment">// 比较数的大小</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 如果数组j大于数组j+1，交换</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-2-算法稳定性"><a href="#2-2-算法稳定性" class="headerlink" title="2.2 算法稳定性"></a>2.2 算法稳定性</h3><p>​		如果待排序的序列中存在两个或两个以上具有相同关键词的数据，排序后这些数据的相对次序保持不变,通俗地讲，就是两个相同的数的相对顺序不会发生改变，则该算法是稳定的；冒泡排序足<strong>稳定的</strong>排序算法。</p>
<h3 id="2-3-时间复杂度"><a href="#2-3-时间复杂度" class="headerlink" title="2.3 时间复杂度"></a>2.3 时间复杂度</h3><p>​		对于n位的数列则有比较次数为(n-1) + (n-2)+ ..+ 1&#x3D;n*(n- 1)&#x2F;2.这就得到了最大的比较次数, n(n-1)&#x2F;2 &#x3D;<br>(n^2 - n)&#x2F;2,计算时间复杂度的时候,忽略常数项1&#x2F;2,再忽略低阶项n ,得到冒泡排序的时间复杂度为<strong>0(n^2)</strong></p>
<h2 id="3、选择排序"><a href="#3、选择排序" class="headerlink" title="3、选择排序"></a>3、选择排序</h2><p>选择排序： 通过一趟遍历，找到最小值的下标。 和下标为0的元素交换。  下一趟，从剩下的元素（排除下标0）， 找到最小值的下标，然后和下标为1的交换。  特点：比较的次数没有减少，但是交换次数一趟只交换一回。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">selectSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">35</span>,<span class="number">22</span>,<span class="number">17</span>,<span class="number">41</span>,<span class="number">72</span>,<span class="number">29</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="comment">// 外层循环控制趟数n个数，只需n-1趟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 假定最小值为a[i]</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> a[i];</span><br><span class="line">            <span class="comment">// 假定最小值的索引为i</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历数组找到最小值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j] &lt; min) &#123;</span><br><span class="line">                    min = a[j];</span><br><span class="line">                    index = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 让最小值和当前a[i]进行交换</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[index];</span><br><span class="line">            a[index] = a[i];</span><br><span class="line">            a[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4、快速排序"><a href="#4、快速排序" class="headerlink" title="4、快速排序"></a>4、快速排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">quickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">23</span>,-<span class="number">9</span>,<span class="number">78</span>,<span class="number">3</span>,<span class="number">34</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">34</span>,<span class="number">23</span>&#125;;</span><br><span class="line">        quickSort(a,<span class="number">0</span>,a.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="comment">// 递归退出条件</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="comment">// l &lt; r，如果r指向的值大于left（最左端的值），r就一直减，直到小于</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[r] &gt;= arr[left]) r--;</span><br><span class="line">            <span class="comment">// l &lt; r，如果r指向的值小于left（最左端的值），l就一直加，直到大于</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[l] &lt;= arr[left]) l++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果l == r，则与left交换，使得l左边一定小于l，右边一定大于l</span></span><br><span class="line">            <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[l];</span><br><span class="line">                arr[l] = arr[left];</span><br><span class="line">                arr[left] = temp;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 否则，l和r交换，使得他们左是小，右是大</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[l];</span><br><span class="line">                arr[l] = arr[r];</span><br><span class="line">                arr[r] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时l一定和r指向同一位置</span></span><br><span class="line">        <span class="comment">// 递归l左</span></span><br><span class="line">        quickSort(arr,left,l - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归l右</span></span><br><span class="line">        quickSort(arr,l + <span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-算法稳定性-1"><a href="#2-2-算法稳定性-1" class="headerlink" title="2.2 算法稳定性"></a>2.2 算法稳定性</h3><p>​		如果待排序的序列中存在两个或两个以上具有相同关键词的数据，排序后这些数据的相对次序保持不变,通俗地讲，就是两个相同的数的相对顺序不会发生改变，则该算法是稳定的；冒泡排序足<strong>不稳定的</strong>排序算法。</p>
<h3 id="2-3-时间复杂度-1"><a href="#2-3-时间复杂度-1" class="headerlink" title="2.3 时间复杂度"></a>2.3 时间复杂度</h3><p><em><img src="/2022/06/03/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220608212049120.png" class title="examplename"></em></p>
<h2 id="5、插入排序"><a href="#5、插入排序" class="headerlink" title="5、插入排序"></a>5、插入排序</h2><h3 id="5-1-思路"><a href="#5-1-思路" class="headerlink" title="5.1 思路"></a>5.1 思路</h3><p>​		假设前面 <strong>n-1</strong>(其中 <strong>n&gt;&#x3D;2</strong>)个数已经是排好顺序的，现将第 <strong>n</strong> 个数插到前面已经排好的序列中，然后找到合适自己的位置，使得插入第n个数的这个序列也是排好顺序的。</p>
<p><em><img src="/2022/06/03/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220609082534593.png" class title="examplename"></em></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">insertSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">23</span>,-<span class="number">9</span>,<span class="number">78</span>,<span class="number">3</span>,<span class="number">34</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">34</span>,<span class="number">23</span>&#125;;</span><br><span class="line">        insertSort(a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i ; j &gt; <span class="number">0</span> ; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                    arr[j - <span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-算法稳定性"><a href="#5-2-算法稳定性" class="headerlink" title="5.2 算法稳定性"></a>5.2 算法稳定性</h3><p>​		如果待排序的序列中存在两个或两个以上具有相同关键词的数据，排序后这些数据的相对次序保持不变,通俗地讲，就是两个相同的数的相对顺序不会发生改变，则该算法是稳定的；冒泡排序足<strong>稳定的</strong>排序算法。</p>
<h3 id="5-3-时间复杂度"><a href="#5-3-时间复杂度" class="headerlink" title="5.3 时间复杂度"></a>5.3 时间复杂度</h3><p>插入排序的平均时间复杂度也是 **O(n^2)**，空间复杂度为常数阶 **O(1)**，具体时间复杂度和数组的有序性也是有关联的。</p>
<p>插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较 <strong>N-1</strong> 次，时间复杂度为 **O(N)**。最坏的情况是待排序数组是逆序的，此时需要比较次数最多，最坏的情况是 **O(n^2)**。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据流中的中位数</title>
    <url>/2022/06/03/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/06/03/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/image-20220603211021526.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li><em><img src="/2022/06/03/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/image-20220603211145163.png" class title="examplename"></em></li>
<li><em><img src="/2022/06/03/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/image-20220603211215786.png" class title="examplename"></em></li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong><ul>
<li><strong>查找中位数 O(1) ：</strong> 获取堆顶元素使用 O(1) 时间；</li>
<li><strong>添加数字 O(logN) ：</strong> 堆的插入和弹出操作使用 O(logN) 时间。</li>
</ul>
</li>
<li><strong>空间复杂度 O(N) ：</strong> 其中 N 为数据流中的元素数量，小顶堆 A 和大顶堆 B 最多同时保存 N 个元素。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; A,B;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line">        A = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(); <span class="comment">// 小顶堆，保存较大的一半</span></span><br><span class="line">        B = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((x,y) -&gt; (y - x)); <span class="comment">// 大顶堆，保存较小的一半</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A.size() != B.size()) &#123;</span><br><span class="line">            A.add(num);</span><br><span class="line">            B.add(A.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            B.add(num);</span><br><span class="line">            A.add(B.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的深度</title>
    <url>/2022/06/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/06/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/image-20220604093059666.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、先序遍历</strong></p>
<ul>
<li><p><strong>解题思路：</strong>加入一个计数器，进行先序遍历。</p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> N 为树的节点数量，计算树的深度需要遍历所有节点。</li>
<li><strong>空间复杂度 O(N) ：</strong> 最差情况下（当树退化为链表时），递归深度可达到 N 。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; max) &#123;</span><br><span class="line">            max = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(root.left);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、后序遍历</strong></p>
<ul>
<li><p><strong>解题思路：</strong>此树的深度和其左（右）子树的深度之间的关系。显然，<strong>此树的深度</strong> 等于 <strong>左子树的深度</strong> 与 <strong>右子树的深度</strong> 中的 <strong>最大值</strong> +1。</p>
<ul>
<li><em><img src="/2022/06/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/image-20220604093454674.png" class title="examplename"></em></li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> N 为树的节点数量，计算树的深度需要遍历所有节点。</li>
<li><strong>空间复杂度 O(N) ：</strong> 最差情况下（当树退化为链表时），递归深度可达到 N 。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3、广度优先遍历</strong></p>
<ul>
<li><p><strong>解题思路：</strong>每遍历一层，则计数器 +1 ，直到遍历完成，则可得到树的深度。</p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> N 为树的节点数量，计算树的深度需要遍历所有节点。</li>
<li><strong>空间复杂度 O(N) ：</strong> 最差情况下（当树平衡时），队列 <code>queue</code> 同时存储 <em>N</em>&#x2F;2 个节点。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;() &#123;&#123; add(root);&#125;&#125;;</span><br><span class="line">        List&lt;TreeNode&gt; tmp;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            tmp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (TreeNode node: queue) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) tmp.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) tmp.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            queue = tmp;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>搜索与回溯</category>
        <category>深度优先遍历</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡二叉树</title>
    <url>/2022/06/04/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/06/04/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220604211525455.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、先序遍历 + 判断深度 （从顶至底）</strong></p>
<ul>
<li><p><strong>解题思路：</strong>思路是构造一个获取当前子树的深度的函数 depth(root) （即 [二叉树的深度 ][<a href="https://nuc462.github.io/2022/06/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/]%EF%BC%89%EF%BC%8C%E9%80%9A%E8%BF%87%E6%AF%94%E8%BE%83%E6%9F%90%E5%AD%90%E6%A0%91%E7%9A%84%E5%B7%A6%E5%8F%B3%E5%AD%90%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%B7%AE">https://nuc462.github.io/2022/06/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/]），通过比较某子树的左右子树的深度差</a> abs(depth(root.left) - depth(root.right)) &lt;&#x3D; 1 是否成立，来判断某子树是否是二叉平衡树。若所有子树都平衡，则此树平衡。</p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<p><em><img src="/2022/06/04/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220604211830493.png" class title="examplename"></em></p>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先序遍历 + 判断深度 （从顶至底）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(maxDepth(root.left) - maxDepth(root.right) ) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、后序遍历 + 剪枝 （从底至顶）</strong></p>
<ul>
<li><p><strong>解题思路：</strong>对二叉树做后序遍历，从底至顶返回子树深度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。</p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N)：</strong> N 为树的节点数；最差情况下，需要递归遍历树的所有节点。</li>
<li><strong>空间复杂度 O(N)：</strong> 最差情况下（树退化为链表时），系统递归需要使用 O(N) 的栈空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后序遍历 + 剪枝 （从底至顶）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> recur(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">recur</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> recur(root.left);</span><br><span class="line">        <span class="keyword">if</span> (left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> recur(root.right);</span><br><span class="line">        <span class="keyword">if</span> (right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(left - right) &lt; <span class="number">2</span> ? Math.max(left,right) + <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>搜索与回溯</category>
        <category>深度优先遍历</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>求1+2+…+n</title>
    <url>/2022/06/05/%E6%B1%821+2+%E2%80%A6+n/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/06/05/%E6%B1%821+2+%E2%80%A6+n/image-20220605163836293.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、递归法</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li><em><img src="/2022/06/05/%E6%B1%821+2+%E2%80%A6+n/image-20220605163918872.png" class title="examplename"></em></li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(n) ：</strong> 计算 n + (n-1) + … + 2 + 1 需要开启 n 个递归函数。</li>
<li><strong>空间复杂度 O(n) ：</strong> 递归深度达到 n ，系统使用 O(n) 大小的额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNums</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> n &gt; <span class="number">1</span> &amp;&amp; sumNums(n - <span class="number">1</span>) &gt; <span class="number">0</span>;</span><br><span class="line">        res += n;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNums</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> n &gt; <span class="number">1</span> &amp;&amp; (n += sumNums(n - <span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>搜索与回溯</category>
        <category>递归</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树的最近公共祖先</title>
    <url>/2022/06/05/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/06/05/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/image-20220605214007542.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>解题思路：</strong></p>
<p><em><img src="/2022/06/05/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/image-20220605214110987.png" class title="examplename"></em></p>
<p><strong>1、迭代</strong></p>
<ul>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> 其中 N 为二叉树节点数；每循环一轮排除一层，二叉搜索树的层数最小为 logN （满二叉树），最大为 N （退化为链表）。</li>
<li><strong>空间复杂度 O(1) ：</strong> 使用常数大小的额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) <span class="comment">// p,q 都在 root 的右子树中</span></span><br><span class="line">                root = root.right; <span class="comment">// 遍历至右子节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) <span class="comment">// p,q 都在 root 的左子树中</span></span><br><span class="line">                root = root.left; <span class="comment">// 遍历至左子节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化：若可保证 p.val &lt; q.val ，则在循环中可减少判断条件。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(p.val &gt; q.val) &#123; <span class="comment">// 保证 p.val &lt; q.val</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> p;</span><br><span class="line">            p = q;</span><br><span class="line">            q = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val &lt; p.val) <span class="comment">// p,q 都在 root 的右子树中</span></span><br><span class="line">                root = root.right; <span class="comment">// 遍历至右子节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; q.val) <span class="comment">// p,q 都在 root 的左子树中</span></span><br><span class="line">                root = root.left; <span class="comment">// 遍历至左子节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、递归</strong></p>
<ul>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> 其中 N 为二叉树节点数；每循环一轮排除一层，二叉搜索树的层数最小为 logN （满二叉树），最大为 N （退化为链表）。</li>
<li><strong>空间复杂度 O(N) ：</strong> 最差情况下，即树退化为链表时，递归深度达到树的层数 N 。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">// 当 p, q 都在 root 的 左子树 中，则开启递归 root.left 并返回</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当 p, q 都在 root 的 右子树 中，则开启递归 root.right 并返回</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>搜索与回溯</category>
        <category>深度优先遍历</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的最近公共祖先2</title>
    <url>/2022/06/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/06/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/image-20220606171303157.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、前序遍历</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<p><em><img src="/2022/06/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/image-20220606171541973.png" class title="examplename"></em></p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> 其中 NN 为二叉树节点数；最差情况下，需要递归遍历树的所有节点。</li>
<li><strong>空间复杂度 O(N) ：</strong> 最差情况下，递归深度达到 NN ，系统使用 O(N)O(N) 大小的额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || p == root || q == root) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当left和right同时为空，说明root的左右子树中都不包含p,q,返回null;（可省略）</span></span><br><span class="line">        <span class="comment">// if (left == null &amp;&amp; right == null) return null;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当 left 为空 ，right 不为空 ：p,q 都不在 root 的左子树中，直接返回 right 。</span></span><br><span class="line">        <span class="comment">// 1. p,q 其中一个在 root 的 右子树 中，此时 right 指向 p（假设为 p ）；</span></span><br><span class="line">        <span class="comment">// 2. p,q 两节点都在 root 的 右子树 中，此时的 right 指向 最近公共祖先节点 ；</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="comment">// 同理</span></span><br><span class="line">        <span class="keyword">if</span> (right == <span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当 left 和 right 同时不为空 ：说明 p, q 分列在 root 的 异侧 （分别在 左 / 右子树），</span></span><br><span class="line">        <span class="comment">// 因此 root 为最近公共祖先，返回 root ；</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>搜索与回溯</category>
        <category>深度优先遍历</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>重建二叉树</title>
    <url>/2022/06/07/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/06/07/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220607215419422.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、分治法（解法一）</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<p><em><img src="/2022/06/07/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220607210740728.png" class title="examplename"></em></p>
</li>
<li><p><strong>复杂度分析：</strong></p>
</li>
<li><p><strong>时间复杂度 O(N) ：</strong> 其中 NN 为树的节点数量。初始化 HashMap 需遍历 inorder ，占用 O(N) 。递归共建立 N 个节点，每层递归中的节点建立、搜索操作占用 O(1) ，因此使用 O(N) 时间。</p>
</li>
<li><p><strong>空间复杂度 O(N) ：</strong> HashMap 使用 O(N) 额外空间；最差情况下（输入二叉树为链表时），递归深度达到 N ，占用 O(N) 的栈帧空间；因此总共使用 O(N) 空间。</p>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 将中序遍历的数组放入map集合，key为它的值，value为它的索引，以便之后找到中序遍历的根节点的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder,<span class="number">0</span>,preorder.length -<span class="number">1</span>,inorder,<span class="number">0</span>,inorder.length -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> preLeft, <span class="type">int</span> preRight, <span class="type">int</span>[] inorder, <span class="type">int</span> inLeft, <span class="type">int</span> inRight)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (preLeft &gt; preRight || inLeft &gt; inRight) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootValue</span> <span class="operator">=</span> preorder[preLeft];</span><br><span class="line">        <span class="comment">// 将根节点赋值给root</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootValue);</span><br><span class="line">        <span class="comment">// 拿到根节点在中序遍历中的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pIndex</span> <span class="operator">=</span> map.get(rootValue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归找它的左右子树节点</span></span><br><span class="line">        root.left = buildTree(preorder,preLeft + <span class="number">1</span>,preLeft + pIndex - inLeft, inorder ,inLeft,pIndex -<span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(preorder,preLeft + pIndex - inLeft + <span class="number">1</span>,preRight, inorder ,pIndex + <span class="number">1</span>,inRight);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>1、分治法（解法二）</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<p><em><img src="/2022/06/07/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220608084217225.png" class title="examplename"></em></p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> 其中 NN 为树的节点数量。初始化 HashMap 需遍历 inorder ，占用 O(N) 。递归共建立 N 个节点，每层递归中的节点建立、搜索操作占用 O(1) ，因此使用 O(N) 时间。</li>
<li><strong>空间复杂度 O(N) ：</strong> HashMap 使用 O(N) 额外空间；最差情况下（输入二叉树为链表时），递归深度达到 N ，占用 O(N) 的栈帧空间；因此总共使用 O(N) 空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] preorder;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; dic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.preorder = preorder;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++)</span><br><span class="line">            dic.put(inorder[i], i);</span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode <span class="title function_">recur</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;                          <span class="comment">// 递归终止</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[root]);          <span class="comment">// 建立根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dic.get(preorder[root]);                       <span class="comment">// 划分根节点、左子树、右子树</span></span><br><span class="line">        node.left = recur(root + <span class="number">1</span>, left, i - <span class="number">1</span>);              <span class="comment">// 开启左子树递归</span></span><br><span class="line">        node.right = recur(root + i - left + <span class="number">1</span>, i + <span class="number">1</span>, right); <span class="comment">// 开启右子树递归</span></span><br><span class="line">        <span class="keyword">return</span> node;                                           <span class="comment">// 回溯返回根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>分治</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux加强版</title>
    <url>/2022/06/12/Linux/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h1 id="一、网络连接的三种方式"><a href="#一、网络连接的三种方式" class="headerlink" title="一、网络连接的三种方式"></a>一、网络连接的三种方式</h1><h2 id="1-1、桥接模式"><a href="#1-1、桥接模式" class="headerlink" title="1.1、桥接模式"></a>1.1、桥接模式</h2><p>虚拟系统可以和外部系统<strong>相互</strong>通讯，但是容易造成ip冲突(超过255个机器)</p>
<h2 id="1-2、NAT模式（网络地址转换模式）"><a href="#1-2、NAT模式（网络地址转换模式）" class="headerlink" title="1.2、NAT模式（网络地址转换模式）"></a>1.2、NAT模式（网络地址转换模式）</h2><p>NAT模式，网络地址转换模式，虚拟系统可以和外部系统<strong>单方面通讯(外部不可以直接访问内部)，</strong>不造成IP冲突，相当于给你虚拟机虚拟一个ip，然后在需要访问外部的时候，自动转换成你母机ip去访问外部</p>
<h2 id="1-3、主机模式"><a href="#1-3、主机模式" class="headerlink" title="1.3、主机模式"></a>1.3、主机模式</h2><p>可以看作一个独立的系统，不与外界进行联系</p>
<p><em><img src="/2022/06/12/Linux/image-20220612105851042.png" class title="examplename"></em></p>
<h1 id="二、Linux目录结构"><a href="#二、Linux目录结构" class="headerlink" title="二、Linux目录结构"></a>二、Linux目录结构</h1><p>1、linux的文件系统是采用层级式的树状目录结构，最上层是根目录”&#x2F;“，然后在此目录下创建其他的目录。</p>
<p>2、<strong>在Linux的世界里，一切皆文件</strong></p>
<ul>
<li>&#x2F;bin (&#x2F;usr&#x2F;bin、&#x2F;usr&#x2F;local&#x2F;bin),是Binary的缩写，存放着最常使用的命令<strong>【常用】</strong></li>
<li>&#x2F;sbin 存放的是系统管理员使用的系统管理程序</li>
<li>&#x2F;home 存放普通用户的主目录，在linux中每个用户都有自己的目录<strong>【常用】</strong></li>
<li>&#x2F;root 系统管理员，也成为超级权限者的用户主目录<strong>【常用】</strong></li>
<li>&#x2F;lib 系统开机所需要的最基本的动态连接共享库</li>
<li>&#x2F;lost+found 一般情况是空的，当系统非法关机后，这里就存放了一些文件</li>
<li>&#x2F;etc 所有的系统管理所需要的配置文件和子目录，例如mysql的my.conf<strong>【常用】</strong></li>
<li>&#x2F;usr 用户的很多应用程序和文件都放在这个目录下，类似于windows的program files目录<strong>【常用】！！</strong></li>
<li>&#x2F;boot 存放的是启动linux时使用的一些核心文件，包括一些连接文件以及镜像文件<strong>【常用】</strong></li>
<li>&#x2F;proc 是一个虚拟目录，是系统内存的映射，访问这个目录来获取系统信息<strong>【不能动】</strong></li>
<li>&#x2F;srv service的缩写，存放一些服务启动之后需要提取的数据<strong>【不能动】</strong></li>
<li>&#x2F;sys linux2.6之后出现，安装了一个文件系统sysfs<strong>【不能动】</strong></li>
<li>&#x2F;tmp 用来存放一些临时文件</li>
<li>&#x2F;dev 类似于Windows的设备管理器，把所有的硬件用文件形式存储</li>
<li>&#x2F;media 会自动识别一些例如u盘光驱等设备，识别后就将识别的设备挂载到这目录下<strong>【常用】</strong></li>
<li>&#x2F;mnt 该目录是为了让用户挂载别的文件系统，可以将外部存储挂载在&#x2F;mnt上，进入该目录查看<strong>【常用】</strong></li>
<li>挂载，指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件。</li>
<li>&#x2F;opt 给主机额外<strong>安装软件</strong>的目录</li>
<li>&#x2F;usr&#x2F;local 另一个给主机额外安装软件所安装的目录，一般是通过编译源码方式安装的程序<strong>【常用】</strong></li>
<li>&#x2F;var 存放一些不断扩张的东西，习惯将经常被修改的目录放在这个目录下，包括各种日志文件<strong>【常用】</strong></li>
<li>&#x2F;selinux [security-enhanced linux] 是一种安全的子系统，它能控制程序只访问特定文件，有三种工作模式，可以自行设置</li>
</ul>
<h1 id="三、vi和vim编辑器"><a href="#三、vi和vim编辑器" class="headerlink" title="三、vi和vim编辑器"></a>三、vi和vim编辑器</h1><h2 id="3-1、三种使用模式"><a href="#3-1、三种使用模式" class="headerlink" title="3.1、三种使用模式"></a>3.1、三种使用模式</h2><p><strong>正常模式(命令模式)</strong></p>
<p> 以vim打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中，你可以使用「上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容，也可以使用『复制、粘贴』来处理你的文件数据。</p>
<p><strong>插入模式</strong></p>
<p> 按下i，I，o，O，a，A，r，R等任何一个字母之后才会进入编辑模式，一般按<strong>i</strong>即可</p>
<p><strong>命令行模式</strong></p>
<p> 输入esc退出当前模式，再输入<code>:</code>进入命令行模式</p>
<p> 可以提供相关指令，完成读取，存盘，替换，离开vim显示行号等动作。</p>
<h2 id="3-2、各种模式的切换"><a href="#3-2、各种模式的切换" class="headerlink" title="3.2、各种模式的切换"></a>3.2、各种模式的切换</h2><p><em><img src="/2022/06/12/Linux/image-20220612150535650.png" class title="examplename"></em></p>
<h2 id="3-3、vim操作"><a href="#3-3、vim操作" class="headerlink" title="3.3、vim操作"></a>3.3、vim操作</h2><p>在一般模式下:</p>
<ul>
<li>yy 拷贝当前行；5yy 拷贝当前向下的5行，p 粘贴 u撤销 x删除</li>
<li>dd 删除当前行；5dd：删除当前向下的5行</li>
<li>G 文档最末行，gg 最首行</li>
<li>先输入行号 在输入shift+g 表示移动到多少行</li>
</ul>
<p>在命令行模式下:</p>
<ul>
<li>wq(保存退出) q(退出) q!(强制退出不保存)</li>
<li>&#x2F;关键字 回车 查找某个单词，输入n是查找下一个</li>
<li>set nu 设置文件的行号，set nonu 取消文件的行号</li>
</ul>
<h1 id="四、开机重启与用户登录注销"><a href="#四、开机重启与用户登录注销" class="headerlink" title="四、开机重启与用户登录注销"></a>四、开机重启与用户登录注销</h1><h2 id="4-1、开关机与重启"><a href="#4-1、开关机与重启" class="headerlink" title="4.1、开关机与重启"></a>4.1、开关机与重启</h2><table>
<thead>
<tr>
<th>命令</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>shutdown -h now</td>
<td>立刻进行关机</td>
</tr>
<tr>
<td>shutdown -h 1</td>
<td>“hello，1分钟后会关机了”</td>
</tr>
<tr>
<td>shutdown -r now</td>
<td>现在重新启动计算机</td>
</tr>
<tr>
<td>halt</td>
<td>关机，作用和上面一样</td>
</tr>
<tr>
<td>reboot</td>
<td>现在重新启动计算机</td>
</tr>
<tr>
<td>sync</td>
<td>把内存的数据同步到磁盘</td>
</tr>
</tbody></table>
<p><strong>注意细节</strong></p>
<ul>
<li>不管是重启系统还是关闭系统，首先要运行sync命令，把内存中的数据写到磁盘中</li>
<li>目前的shutdown&#x2F;reboot&#x2F;halt等命令均已经在关机前进行了sync，但是还是自己执行一次比较好</li>
</ul>
<h2 id="4-2、用户登录和注销"><a href="#4-2、用户登录和注销" class="headerlink" title="4.2、用户登录和注销"></a>4.2、用户登录和注销</h2><p><strong>基本介绍</strong></p>
<ol>
<li>登录的时候尽量少使用root账号登录，因为他是系统管理员，最大的权限，避免操作失误。可以利用普通用户登录，登录后再用“su - 用户名” 命令来切换成系统管理员身份</li>
<li>在提示符下输入logout即可注销用户</li>
</ol>
<table>
<thead>
<tr>
<th>命令</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>su - 用户名</td>
<td>切换用户</td>
</tr>
<tr>
<td>logout</td>
<td>注销用户</td>
</tr>
</tbody></table>
<h1 id="五、Linux用户管理"><a href="#五、Linux用户管理" class="headerlink" title="五、Linux用户管理"></a>五、Linux用户管理</h1><p>linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统</p>
<h2 id="5-1、用户基本操作"><a href="#5-1、用户基本操作" class="headerlink" title="5.1、用户基本操作"></a>5.1、用户基本操作</h2><table>
<thead>
<tr>
<th>命令</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>useradd 用户名</td>
<td>添加用户，默认该用户的家目录在&#x2F;home&#x2F;用户名 下</td>
</tr>
<tr>
<td>useradd -d 指定目录 用户名</td>
<td>给新创建的用户指定家目录</td>
</tr>
<tr>
<td>useradd -g 用户组 用户名</td>
<td>增加用户时直接加上组</td>
</tr>
<tr>
<td>passwd 用户</td>
<td>给某个用户设置密码</td>
</tr>
<tr>
<td>pwd</td>
<td>显示当前用户所在目录</td>
</tr>
<tr>
<td>userdel 用户名</td>
<td>删除用户但保留对用home目录</td>
</tr>
<tr>
<td>userdel -r 用户名</td>
<td>删除用户并且删除对应home目录</td>
</tr>
<tr>
<td>id 用户名</td>
<td>查询用户信息</td>
</tr>
<tr>
<td>su - 切换的用户名</td>
<td>切换用户，高权限切换地全选不需要密码，反之需要</td>
</tr>
<tr>
<td>exot&#x2F;logout</td>
<td>返回到原来用户</td>
</tr>
<tr>
<td>who am i&#x2F; whoami</td>
<td>查看当前用户，不加空格是当前操作的用户，加空格是第一次登录的用户的信息</td>
</tr>
</tbody></table>
<h2 id="5-2、用户组"><a href="#5-2、用户组" class="headerlink" title="5.2、用户组"></a>5.2、用户组</h2><p><strong>介绍：</strong></p>
<p>类似于角色，系统可以对有共性&#x2F;权限的多个用户进行统一的管理，所有在一个组的用户都会有这个组的权限</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>groupadd 组名</td>
<td>新增组</td>
</tr>
<tr>
<td>groupdel 组名</td>
<td>删除组</td>
</tr>
<tr>
<td>useradd -g 用户组 用户名</td>
<td>增加用户时直接加上组</td>
</tr>
</tbody></table>
<p>如果直接添加用户而不指定组，则虚拟机会默认创建一个以用户名为名的组并将其放入组中</p>
<h2 id="5-3、用户和组相关文件"><a href="#5-3、用户和组相关文件" class="headerlink" title="5.3、用户和组相关文件"></a>5.3、用户和组相关文件</h2><ul>
<li>&#x2F;etc&#x2F;passwd 文件</li>
</ul>
<p>用户(user)的配置文件，记录用户的各种信息</p>
<p>每一行都是一个用户：含义: <strong>用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录shell</strong></p>
<ul>
<li>&#x2F;etc&#x2F;shadow文件</li>
</ul>
<p>口令配置文件,每行的含义:<strong>登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</strong></p>
<ul>
<li>&#x2F;etc&#x2F;group文件</li>
</ul>
<p>组的配置文件，记录linux中组的信息，每行含义:<strong>组名:口令:组标识号:组内用户列表</strong></p>
<h1 id="六、实用指令"><a href="#六、实用指令" class="headerlink" title="六、实用指令"></a>六、实用指令</h1><h2 id="6-1、运行级别"><a href="#6-1、运行级别" class="headerlink" title="6.1、运行级别"></a>6.1、运行级别</h2><p>运行级别说明</p>
<ol>
<li>关机</li>
<li>单用户[找回丢失的密码]</li>
<li>多用户状态没有网络服务</li>
<li>多用户状态有网络服务</li>
<li>系统未使用保留给用户</li>
<li>图形界面</li>
<li>系统重启</li>
</ol>
<p>常用的运行级别是3和5，也可以指定默认运行级别</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>init[0123456]</td>
<td>切换不同的运行级别</td>
</tr>
<tr>
<td>systemctl get-default</td>
<td>查看目前的运行级别</td>
</tr>
<tr>
<td>systemctl set-default mult-user.target&#x2F;systemctl set-default graphical.target</td>
<td>设置运行级别，前者相当于3，后者相当于5（改变默认的级别）</td>
</tr>
</tbody></table>
<h2 id="6-2、找回root密码-Centos7-6-以后"><a href="#6-2、找回root密码-Centos7-6-以后" class="headerlink" title="6.2、找回root密码(Centos7.6 以后)"></a>6.2、找回root密码(Centos7.6 以后)</h2><ol>
<li>启动系统，进入开机页面，在页面中按‘e’进入编辑界面 (5s之内)</li>
<li>进入之后使用键盘的上下键移动光标，找到以“Linux 16”开头所在的行数，在行的最后输入<code>:init=/bin/sh</code></li>
<li>输入之后按快捷键<code>Ctrl + x</code> 进入单用户模式</li>
<li>在光标闪烁的位置输入<code>mount -o remount,rw /</code> (单词间有空格)，然后按回车</li>
<li>在新的一行最后面输入<code>passwd</code>。完成后按回车输入密码，然后再次确认密码即可</li>
<li>接着在鼠标闪烁的位置输入<code>: touch /.autorelabel</code>(touch 后面有空格),之后继续按回车</li>
<li>接着在光标闪烁的位置输入 <code>exec /sbin/init</code> 之后按回车键，等待系统修改密码(过程时间有点长)，完成后系统会自动重启</li>
</ol>
<h2 id="6-3、帮助指令"><a href="#6-3、帮助指令" class="headerlink" title="6.3、帮助指令"></a>6.3、帮助指令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>man [命令或配置文件]</td>
<td>获得帮助信息</td>
</tr>
<tr>
<td>help 命令</td>
<td>获得shell内置命令的帮助信息</td>
</tr>
</tbody></table>
<h2 id="6-4、文件目录类"><a href="#6-4、文件目录类" class="headerlink" title="6.4、文件目录类"></a>6.4、文件目录类</h2><ul>
<li><strong>pwd</strong> 显示当前工作目录的绝对路径</li>
<li><strong>ls</strong> 显示目录:常用选项: <strong>-a</strong>,显示所有，包括隐藏的，**-l** 以列表 <strong>-lh</strong> (h是human的意思)指的是按照人类比较容易看的方式显示</li>
<li><strong>cd</strong> 定位相对路径或绝对路径 **cd~<strong>回到自己的home目录，</strong>cd..**回到上级目录</li>
<li><strong>mkdir</strong> 创建目录 mkdir [选项] 要创建的目录 <strong>-p</strong>为创建多级目录</li>
<li><strong>rmdir</strong> 删除目录 mkdir[选项] 要删除的空目录 ，如果需要删除非空目录，需要使用<strong>rm -rf</strong> 要删除的目录 <strong>-r</strong>表示递归，<strong>f</strong>表示强制删除</li>
<li><strong>touch</strong> 创建空文件</li>
<li><strong>cp</strong> 拷贝文件到指令目录 <strong>cp [选项] 文件 指定目录</strong> 选项:<strong>-r</strong> 递归复制整个文件夹， **\cp [选项] 文件 指定目录 ** 强制覆盖不提示</li>
<li><strong>rm</strong> 移除文件或目录 rm[选项] 要删除的文件或目录，**-r**递归 <strong>-f</strong>强制删除不提示</li>
<li><strong>mv</strong> 移动文件或重命名 重命名（同一个目录）:<strong>mv old文件名 new文件名</strong> 移动: <strong>mv &#x2F;old位置 &#x2F;new位置</strong></li>
<li><strong>cat</strong> 查看文件内容 <code>-n</code><strong>显示行号</strong> 为了浏览方便一般会加上 <strong>|more</strong>  （管道命令：把前面的结果交给下一个指令）</li>
<li><strong>more</strong> 要查看的文件 ，指令中内置了快捷键，可以独立使用 也可以与 <strong>cat</strong> 命令一起使用<ul>
<li>空格键(space) 向下翻一页</li>
<li>回车键(Enter) 向下翻一行</li>
<li>q 立刻离开</li>
<li>Ctrl+f 向下滚动一屏</li>
<li>Ctrl+B 返回上一屏</li>
<li>&#x3D; 输出当前行的行号</li>
<li>:f 输出文件名和当前行的行号</li>
</ul>
</li>
<li><strong>less</strong> 分屏查看文件内容，与more类似却更加强大，他是懒加载模式<ul>
<li>空格键(space) 向下翻一页</li>
<li>下键(pagedown) 向下翻一页</li>
<li>上建(pageup) 向上翻一页</li>
<li>&#x2F; 向下搜索字串功能 n向下查找；N向上查找</li>
<li>？ 向上搜索字串功能 n向上查找；N向下查找</li>
<li>q 立刻离开</li>
</ul>
</li>
<li><strong>echo</strong> 输出内容到控制台，例如要输出环境变量 echo $PATH</li>
<li><strong>head</strong> 显示文件开头的部分内容，默认十行 <strong>head -n 任意数字</strong>，查看前任意行</li>
<li><strong>tail</strong> 显示文件中尾部内容，默认十行 <strong>tail -n 任意数字</strong> 查看尾n行 <strong>tail -f</strong> 实时追踪文件更新</li>
<li><strong>&gt;与&gt;&gt;</strong> 输出重定向(覆盖)和追加<ul>
<li>ls -l &gt; 文件 列表的内容写入到文件中(覆盖)</li>
<li>ls -al &gt;&gt;文件 列表内容追加到文件的末尾</li>
<li>cat 文件1&gt;文件2 文件1内容覆盖到文件2(覆盖)</li>
<li>echo “内容” &gt;&gt; 文件 将内容追加到文件末尾</li>
</ul>
</li>
<li><strong>cal</strong> 显示当前的日历信息。</li>
<li><strong>ln</strong> 软连接，也被称为符号链接，类似于Windows的快捷方式 <strong>ln -s [源文件或目录] [软连接名]</strong> 删除软连接<strong>rm</strong>的时候最后不要带上&#x2F;，<strong>ln [源文件或目录] [硬连接名]</strong> <ul>
<li><em><img src="/2022/06/12/Linux/image-20220612193436262.png" class title="examplename"></em></li>
<li><strong>注意点:</strong><ul>
<li><strong>创建硬链接使用相对路径和绝对路径都可以</strong></li>
<li><strong>删除源文件，硬链接还可以访问到数据。</strong></li>
<li><strong>创建硬链接，硬链接数会加1，删除源文件或者硬链接，硬链接数会减1。</strong></li>
<li><strong>创建软链接，硬链接数不会加1</strong></li>
<li><strong>不能给目录创建硬链接</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>history</strong> 查看已经执行过的历史命令 后面加数字是查看最近的n个命令，查看的命令前会带有参数，可以直接**!+参数（编号）**来执行命令</li>
</ul>
<p>ll查询下的：</p>
<p><em><img src="/2022/06/12/Linux/image-20220612193240750.png" class title="examplename"></em></p>
<h2 id="6-5、时间日期类"><a href="#6-5、时间日期类" class="headerlink" title="6.5、时间日期类"></a>6.5、时间日期类</h2><ul>
<li>date指令-显示当前日期<ul>
<li>date （功能描述：显示当前时间）</li>
<li>date + %Y (功能描述：显示当前年份)</li>
<li>date + %m (功能描述：显示当前月份)</li>
<li>date + %d (功能描述：显示当前是哪一天)</li>
<li>date “+%Y-%m-%d %H:%M:%S” (功能描述：显示年月日时分秒)</li>
<li>date -s 字符串时间 设置日期</li>
</ul>
</li>
<li>cal +选项 查看日历，不加选项默认本月,加了就是参数当年的日历</li>
</ul>
<h2 id="6-6、搜索查找类"><a href="#6-6、搜索查找类" class="headerlink" title="6.6、搜索查找类"></a>6.6、搜索查找类</h2><ul>
<li><p><strong>find</strong>从指定目录<strong>向下递归遍历</strong>其各个子目录，将满足条件的文件或目录显示在终端</p>
</li>
<li><p><strong>语法:find [搜索范围] [选项]</strong> </p>
</li>
<li><p>选项: </p>
<ul>
<li>-name&lt;查询方式&gt; 按照指定的文件名查找模式查找文件</li>
<li>-user&lt;用户名&gt; 查找属于指定用户名的所有文件</li>
<li>-size&lt;文件大小&gt; 按照指定的文件大小查找文件</li>
</ul>
<p><em><img src="/2022/06/12/Linux/image-20220703113544547.png" class title="examplename"></em></p>
</li>
<li><p><strong>locate</strong>快速定位文件路径，locate指令利用事先建立的系统中所有文件名称以及路径的locate数据库实现快速定位给定的文件需遍历整个系统，速度较快，但为了保证查询结果的准确度，管理员必须定期更新locate时刻。 <strong>语法：</strong>locate 搜索文件,<strong>执行之前 必须先执行updatedb</strong></p>
<p>由于locate指令基于数据库查询，所以第一次查找前必须使用updatedb指令来创建一个新的locate库</p>
</li>
<li><p>which 可以查看某个指令在哪个目录下，比如 ls 指令在哪个目录，which ls</p>
</li>
<li><p>grep和管道符”|” 过滤查找，管道符”|”表示<strong>将前一个命令的处理结果输出传递给后面的命令</strong>处理，基本语法: grep [选项] 查找内容，源文件 -n显示匹配行及行号，-i忽略字母大小写</p>
</li>
</ul>
<h2 id="6-7、压缩和解压类"><a href="#6-7、压缩和解压类" class="headerlink" title="6.7、压缩和解压类"></a>6.7、压缩和解压类</h2><h1 id="十四、Shell编程"><a href="#十四、Shell编程" class="headerlink" title="十四、Shell编程"></a>十四、Shell编程</h1><h2 id="14-1、Shell是什么"><a href="#14-1、Shell是什么" class="headerlink" title="14.1、Shell是什么"></a>14.1、Shell是什么</h2><p>Shell是一个命令行解释器，它为用户提供了一个向Linux内核发生请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。</p>
<p><em><img src="/2022/06/12/Linux/image-20220612203240772.png" class title="examplename"></em></p>
<h2 id="14-2、Shell脚本的执行方式"><a href="#14-2、Shell脚本的执行方式" class="headerlink" title="14.2、Shell脚本的执行方式"></a>14.2、Shell脚本的执行方式</h2><p><strong>脚本格式要求：</strong></p>
<p>1、脚本以 <strong>#!&#x2F;bin&#x2F;bash</strong> 开头</p>
<p>2、脚本需要有可执行权限</p>
<p><strong>脚本的常用执行方式</strong></p>
<p>方式1：(输入脚本的绝对路径或相对路径)</p>
<p><strong>说明：</strong>首先要赋予hellowordl.sh脚本的+x权限，在执行脚本</p>
<p>方式2：(sh+脚本)</p>
<p><strong>说明：</strong>不用赋予脚本+x权限，直接sh + 脚本执行即可。</p>
<p><a href="https://www.eliseo.top/2022/05/05/Linux/image-20220531092746464.png"><img src="https://www.eliseo.top/2022/05/05/Linux/image-20220531092746464.png" alt="img"></a></p>
<h2 id="14-3、Shell的变量"><a href="#14-3、Shell的变量" class="headerlink" title="14.3、Shell的变量"></a>14.3、Shell的变量</h2><hr>
<p><strong>Shell变量介绍</strong></p>
<p>1、分为系统变量和用户自定义变量</p>
<p>2、系统变量：$HOME、$PWD、$SHELL、$USER等</p>
<p>3、显示当前shell中所有变量：set</p>
<hr>
<p><strong>shell变量的定义</strong></p>
<p><strong>基本语法：</strong><br>1、定义变量：变量名&#x3D;值(不能打空格)</p>
<p>2、撤销变量：unset 变量</p>
<p>3、声明静态变量：readonly变量，<strong>注意：不能unset</strong></p>
<p>4、输出变量：echo $变量名 或者echo 变量名&#x3D;$变量名 或者echo “变量名&#x3D;$变量名”；第一个输出结果为 变量名的值，后两个输出结果一样 都是 变量名&#x3D;值</p>
<p><strong>定义变量的规则：</strong></p>
<p>1、变量名称可以有字母、数字、下划线组成，但是不能以数字开头</p>
<p>2、等号两侧不能有空格</p>
<p>3、变量名称一般习惯为大写，这是一个规范，也就是说哪怕定义的是小写也不会报错，但是 <code>不好</code></p>
<p><strong>将命令的返回值赋给变量</strong></p>
<p>1、A&#x3D;<code>date</code>反引号，运行里面的命令，并且把结果返回给变量A，如果不加反引号，那么就是将date单词赋给A。</p>
<p>2、A&#x3D;$(date) 等价于反引号</p>
<h2 id="14-4、设置环境变量"><a href="#14-4、设置环境变量" class="headerlink" title="14.4、设置环境变量"></a>14.4、设置环境变量</h2>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>数值的整数次方</title>
    <url>/2022/07/05/%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/07/05/%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/image-20220705232121664.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><ul>
<li><p><strong>解题思路：</strong></p>
<p><em><img src="/2022/07/05/%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/image-20220705232200972.png" class title="examplename"></em></p>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(log_2 n) ：</strong> 二分的时间复杂度为对数级别。</li>
<li><strong>空间复杂度 O(1) ：</strong> res, b 等变量占用常数大小额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 超时算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            n = -n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> x;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">                x = x * a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>good算法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速幂法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// -n会溢出，但在long形态里面，还是表示的-2147483648，为什么呢？</span></span><br><span class="line">        <span class="comment">// n = -2147483648(对应计算机里的补码表示)</span></span><br><span class="line">        <span class="comment">// -n 对应计算机里面的真实（补码）表示，和n的补码表示一样，因为已经溢出了，表示不了了。</span></span><br><span class="line">        <span class="comment">// 因为根据求相反数的规则：对n求相反数，就对n进行从右往左数，第1个1不变，其他的二进制位变成相反数即可。</span></span><br><span class="line">        <span class="comment">// 参考百度百科补码表示：https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81</span></span><br><span class="line">        <span class="comment">// int 取值范围  -2^31——2^31-1  -2147483648——2147483647</span></span><br><span class="line">        <span class="comment">// b = -n ; //  b = -2147483648， 错误代码</span></span><br><span class="line">        <span class="comment">// b = -b;  // b = 2147483648，正确代码，-b也可以在  正数范围内进行表示。</span></span><br><span class="line">        <span class="comment">// 所以必须使用long</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// （与操作）：判断末尾的二进制数是1还是0</span></span><br><span class="line">            <span class="keyword">if</span> ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) res *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            <span class="comment">// （移位操作）： nn 右移一位（可理解为删除最后一位）。</span></span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>分治</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM中关于常量池解析的相关说明</title>
    <url>/2022/07/06/JVM%E4%B8%AD%E5%85%B3%E4%BA%8E%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%A7%A3%E6%9E%90%E7%9A%84%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h1 id="JVM中关于常量池解析的相关说明"><a href="#JVM中关于常量池解析的相关说明" class="headerlink" title="JVM中关于常量池解析的相关说明"></a>JVM中关于常量池解析的相关说明</h1><p><strong>相关知识点：</strong></p>
<ul>
<li><p><a herf="https://blog.csdn.net/qq_42629806/article/details/99842776?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166363258016782391822840%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166363258016782391822840&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-99842776-null-null.142^v47^pc_rank_34_default_23,201^v3^control_2&utm_term=JVM%E4%B8%AD%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE&spm=1018.2226.3001.4187">静态常量池与运行时常量池</a></p>
</li>
<li><p><a herf="https://blog.csdn.net/Leon_Jinhai_Sun/article/details/125016637">动态链接</a></p>
</li>
<li><p>[动态链接]:<a href="https://blog.csdn.net/Leon_Jinhai_Sun/article/details/125016637">https://blog.csdn.net/Leon_Jinhai_Sun/article/details/125016637</a>	“[动态链接]”</p>
</li>
<li><p>类装载器子系统</p>
</li>
<li><p><strong>符号引用</strong>：包含<strong>字面量</strong>(Literal)和<strong>符号引用量</strong>(Symbolic References)，字面量相当于Java语言层面常量的概念，如<strong>文本字符串，声明为final的常量值</strong>等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：<strong>类和接口的全限定名、字段名称和描述符、方法名称和描述符</strong></p>
</li>
</ul>
<p><em><img src="/2022/07/06/JVM%E4%B8%AD%E5%85%B3%E4%BA%8E%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%A7%A3%E6%9E%90%E7%9A%84%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/image-20220920094612132.png" class title="examplename"></em></p>
]]></content>
      <categories>
        <category>基础</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
