<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>No primary or default constructor found for interface java.util.List原因和解决方法</title>
    <url>/2022/04/24/No%20primary%20or%20default%20constructor%20found%20for%20interface%20java.util.List%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>是list是接口，没有<strong>构造函数</strong></p>
<span id="more"></span>

<p><strong>解决方法：</strong></p>
<ul>
<li>换成ArrayList就可以，</li>
<li>将List转为Json字符串（JSON.toJSONString(list)），或者加入@RequestBody注解</li>
<li>目标对象不匹配，用＠RequestParam让他强制匹配</li>
</ul>
]]></content>
      <categories>
        <category>异常</category>
      </categories>
      <tags>
        <tag>异常</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>认证与授权实现思路</title>
    <url>/2022/04/24/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="认证与授权实现思路"><a href="#认证与授权实现思路" class="headerlink" title="认证与授权实现思路"></a>认证与授权实现思路</h2><p>Spring Security其实就是用<strong>filter</strong>，多请求的路径进行过滤。</p>
<span id="more"></span>

<p>​	如果系统的模块众多，每个模块都需要就行授权与认证，所以我们选择基于token的形式进行授权与认 证，用户根据用户名密码认证成功，然后获取当前用户角色的一系列权限值，并以用户名为key，权限列 表为value的形式存入redis缓存中，根据用户名相关信息生成token返回，浏览器将token记录到cookie中， 每次调用api接口都默认将token携带到header请求头中，Spring-security解析header头获取token信息，解 析token获取当前用户名，根据用户名就可以从redis中获取权限列表，这样Spring-security就能够判断当前 请求是否有权限访问</p>
<p><em><img src="/2022/04/24/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/image-20220424191422878.png" class title="examplename"></em></p>
]]></content>
      <categories>
        <category>面试</category>
        <category>面试题</category>
        <category>权限</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>面试题</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title>应战秋招总结</title>
    <url>/2022/04/21/%E5%BA%94%E6%88%98%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="1、何为秋招？"><a href="#1、何为秋招？" class="headerlink" title="1、何为秋招？"></a>1、何为秋招？</h2><h3 id="1-1、应届生"><a href="#1-1、应届生" class="headerlink" title="1.1、应届生"></a>1.1、应届生</h3><p>暑假：大学生（实习、工作）</p>
<span id="more"></span>

<p>8月、春招！</p>
<p>应届毕业生！</p>
<p>2015年级 2019界 2016年级 2020界</p>
<p>应届毕业生： 大三升大四！</p>
<p><strong>大三暑假找工作找实习！</strong></p>
<p>大四：毕业再找！切记、不好！</p>
<p>2020校招！不收2019届！</p>
<h3 id="1-2、秋招-x2F-春招-x2F-校招"><a href="#1-2、秋招-x2F-春招-x2F-校招" class="headerlink" title="1.2、秋招&#x2F;春招&#x2F;校招"></a>1.2、秋招&#x2F;春招&#x2F;校招</h3><p>校招： 校园招聘</p>
<p>流程：网申-笔试-面试（23轮）-录取通知-体检-签三方-毕业！-上班！ 秋招： 7来年一月 7~10，校招核心！</p>
<p>秋招名额远大于春招！</p>
<p>招聘信息 宣讲会 招聘会</p>
<p>春招： 春节到6月 3~4、秋招补录！</p>
<blockquote>
<p>网申（不打无准备的仗）</p>
</blockquote>
<p>网络在线申请，大型企业！</p>
<p>注意：填表格！</p>
<p>开放性问题：优缺点？失败经历？公司的看法？</p>
<p>一定要仔细？大三时候就一定要准备好！</p>
<p>复制到记事本！</p>
<blockquote>
<p>宣讲会</p>
</blockquote>
<p>公司 HR、技术！ 讲解公司的内容、岗位、待遇、Q&amp;A？</p>
<p>1、开完就走！</p>
<p>2、现场接受简历</p>
<p>3、现场接受简历、面试！一分钟（记住你！ 准备60s的自我介绍）</p>
<p>4、现场接受简历、面试、笔试！</p>
<p><strong>多跑!</strong></p>
<blockquote>
<p>招聘会（多对一）体验一次！</p>
</blockquote>
<p>政府: 人力资源组织 ! 现场招聘&#x2F;网络招聘</p>
<p><strong>现场招聘</strong></p>
<p>综合&#x2F;理工科&#x2F;经管文科</p>
<p><strong>准备：</strong></p>
<p>HR、直接递交简历。现场面试， hR！</p>
<p>1、简历！</p>
<p>2、带上U盘！资料文件！防备不时之需</p>
<p>3、目标确定性： 1000家公司（2~3 公司的信息、岗位需要的职业技能！） 简历是可以改变的！（掌握技能、实习工作经历） 3个公司、3份不一样的（根据公司的需要来定 制！）</p>
<h3 id="1-3、社招-x2F-海投"><a href="#1-3、社招-x2F-海投" class="headerlink" title="1.3、社招&#x2F;海投"></a>1.3、社招&#x2F;海投</h3><blockquote>
<p>社招： 社会招聘！ 目标人群： 毕业的人、经验人士！</p>
</blockquote>
<p>社招持续存在！</p>
<p>社招: 校招是有新人培训！社招直接进去就工作！ 一定都是招收有经验的人士！</p>
<p>参加校招：大四！不要在毕业之后！</p>
<p>大三~大四！重视校招！</p>
<p>社招: 猎头、打造知名度（开源项目、博客、媒体影响力！）</p>
<blockquote>
<p>海投: 广撒网！</p>
</blockquote>
<p>不建议：没有针对！</p>
<p>百度、阿里：做了准备、历届面试题、实训！</p>
<p>投的数量多不一定有用！</p>
<p>不打无准备的仗： 秋招、社招（选定心仪的公司！ 2~3）</p>
<p>1、集中精力研究这些公司的面试！</p>
<p>2、努力提升自己的技能！拿到再多的oﬀer ，最终你只能选择一家！ 面试！一开始就选择了！</p>
<p>100家公司！ 没有人鸟你，自我否定！</p>
<h2 id="2、秋招信息如何获取？"><a href="#2、秋招信息如何获取？" class="headerlink" title="2、秋招信息如何获取？"></a>2、秋招信息如何获取？</h2><p>秋招：获取秋招信息</p>
<p>1、公司官网+官方招聘公众号！正规</p>
<p>2、内推（熟人内部推荐！群里&#x2F;公众号）学长、学姐</p>
<p>3、牛客网！专业的网站去找咨询！</p>
<p>牛客求职区：<a href="https://www.nowcoder.com/recommend">https://www.nowcoder.com/recommend</a></p>
<p>牛客讨论区：<a href="https://www.nowcoder.com/discuss">https://www.nowcoder.com/discuss</a></p>
<p>校招日程汇总：<a href="https://www.nowcoder.com/school/schedule">https://www.nowcoder.com/school/schedule</a></p>
<p>大数据：筛选出有用的消息！</p>
<p>不要超过5家公司！</p>
<p>百度、阿里、腾讯、美团、京东</p>
<p><strong>到社会上第一步: 选择</strong></p>
<p>1、钱多事少离家近 （钱多）</p>
<p>2、背书，大公司！ 证明！</p>
<p>3、锻炼自己！<br>工资 、能力对等！</p>
<h2 id="3、如何备战秋招？"><a href="#3、如何备战秋招？" class="headerlink" title="3、如何备战秋招？"></a>3、如何备战秋招？</h2><h3 id="3-1、简历（ps做简历）"><a href="#3-1、简历（ps做简历）" class="headerlink" title="3.1、简历（ps做简历）"></a>3.1、简历（ps做简历）</h3><p><strong>1、模板！</strong></p>
<ul>
<li>word 黑白字！</li>
<li>一定要找一个稳健的模板（工作相关的模板）</li>
<li>尽量不要太多（最多2~3张&#x2F; 1张能解决是最好的）</li>
<li>突出主题（线上发邮件：PDF！不要发word、文 字乱码！）</li>
<li>颜值高、照片！（大学都去拍摄一组正装的艺术照！）</li>
<li>不同的公司岗位你要写不同的简历！</li>
<li>内容：<ul>
<li>个人信息： 姓名、求职岗位、手机号、邮箱地址（突出显示、一下子就能看到自己的联系方式）</li>
<li>学校的学历： 毕业院校、本科：直接写本科院校：研究生：本科毕业院校、研究生毕业院校。有的公司敲门砖就是 985&#x2F;211<ul>
<li>问题：我的学校不够好？ 学校不是最致命的条件、毕业院校不是很好（重点就是 实习经历+项目经历</li>
</ul>
</li>
<li>博客&#x2F;影响力的东西：一定要突出！（价值） 学习一定要产出！</li>
<li>实习经历：（重中之重）<ul>
<li>大厂实习经历！最好的！</li>
<li>假设没有实习经历。 突出项目经历！</li>
<li>项目经历： 自己在学校做过哪些项目 真实，自己做过哪些项目经历</li>
<li>切记不要流水账！<ul>
<li>我做了什么项目</li>
<li>我在项目中负责那一部分</li>
<li>在项目开发中遇到了哪些难题 我是怎么处理和解决的！</li>
</ul>
</li>
<li>不要伪造（培训机构出来的人，大部分都会伪造项目经历和工作年龄！）</li>
</ul>
</li>
</ul>
</li>
<li>校园经历：<ul>
<li>学生会、社团。自己在学校举办的活动。</li>
<li>获奖经历。</li>
<li>奖学金</li>
</ul>
</li>
<li>掌握的技能<ul>
<li>如实的写</li>
<li>熟悉、精通（少用精通，最多1~2个精通！）</li>
<li>面试会通过这个来问你！</li>
<li>不要在这里给自己挖坑！</li>
</ul>
</li>
</ul>
<p>2、真实！</p>
<p>3、措辞！</p>
<h3 id="3-2、笔试准备"><a href="#3-2、笔试准备" class="headerlink" title="3.2、笔试准备"></a>3.2、笔试准备</h3><p>技术岗（编程和问答！）</p>
<p>解决方法：看书+练题！多锻炼自己的说话能力！</p>
<p>练题不要瞎练习：针对性练习题目</p>
<p>目标：</p>
<p>找到历届的笔试面试题！ 提前3个月做准备！ 刷题+属性以前的套路！</p>
<ul>
<li><p>名企笔试真题练习：<a href="https://www.nowcoder.com/contestRoom">https://www.nowcoder.com/contestRoom</a></p>
</li>
<li><p>校招笔试真题汇总：<a href="https://www.nowcoder.com/contestRoom?mutiTagIds=1657">https://www.nowcoder.com/contestRoom?mutiTagIds=1657</a></p>
</li>
</ul>
<p>校招备战学习计划：<a href="https://www.nowcoder.com/studypath/1">https://www.nowcoder.com/studypath/1</a></p>
<ul>
<li><p>在线编程：<a href="https://www.nowcoder.com/activity/oj">https://www.nowcoder.com/activity/oj</a></p>
</li>
<li><p>剑指oﬀer在线编程：<a href="https://www.nowcoder.com/ta/coding-interviews">https://www.nowcoder.com/ta/coding-interviews</a></p>
</li>
</ul>
<p>不打无准备的仗！</p>
<p>算法很重要，没有套路，就是多刷题！一定要多花时间研究！</p>
<p>大学生：4年！</p>
<p>大一大二就扎实学习基础技能！</p>
<p>大三了解公司，了解面试，刷题！</p>
<p>大三暑假：找实习找工作</p>
<p>大四就是毕业、交朋友、熟悉公司、到社会！</p>
<h3 id="3-3、面试准备"><a href="#3-3、面试准备" class="headerlink" title="3.3、面试准备"></a>3.3、面试准备</h3><p>多看面经！</p>
<p>每个公司的面试风格都不同！</p>
<ul>
<li><p>牛客讨论区：<a href="https://www.nowcoder.com/discuss">https://www.nowcoder.com/discuss</a></p>
</li>
<li><p>各岗位汇总目录：<a href="https://www.nowcoder.com/discuss/167046">https://www.nowcoder.com/discuss/167046</a></p>
</li>
<li><p>各公司面经汇总目录：<a href="https://www.nowcoder.com/discuss/161635">https://www.nowcoder.com/discuss/161635</a></p>
</li>
</ul>
<p>1、多看他人的面经？</p>
<p>2、善于总结自己的面试经验？多分享（交流）</p>
<p>练手：</p>
<p>中意大公司，面试很紧张！</p>
<p>去小公司面试锻炼：慢慢找到自己的不足，锻炼经验，保证自己面试不经常！</p>
<p>练到自己不紧张不惧怕面试了就可以去自己中意的公司面试！</p>
<p>要把最好的状态留个最重要的面试！</p>
<p>面试：不断地打击自信心的过程！</p>
<p>千万不要对自己失去信心！</p>
<p>最黑暗时刻、就是黎明前！</p>
<p>坚持：多找自己的问题，弥补不足，在尝试！</p>
<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>1、秋招时机，提前批、内推、公众平台、社会招聘、…… 信息很重要！</p>
<p>2、早些做好自己的职业规划（大三之前）</p>
<p>3、写一个优秀的简历。不是自我介绍，而是让公司看到简历之后知道为什么需要你！简历是可以有多 份！</p>
<p>4、笔试和面试尽量提前3个月准备充分！提前了解公司！<br>参考链接：<a href="https://www.bilibili.com/video/BV16C4y1t7Mi%EF%BC%8C%E8%B5%84%E6%BA%90%E6%9D%A5%E8%87%AA**%E7%8B%82%E7%A5%9E%E8%AF%B4**yyds%EF%BC%81">https://www.bilibili.com/video/BV16C4y1t7Mi，资源来自**狂神说**yyds！</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>招聘</tag>
      </tags>
  </entry>
  <entry>
    <title>java.util.concurrentmodificationexception异常原因和解决方法</title>
    <url>/2022/04/24/java.util.concurrentmodificationexception%E5%BC%82%E5%B8%B8%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>简单地说下原因，在我那个项目的代码中，遍历的方式是增强 for 循环，在底层使用的也是迭代器。</p>
<span id="more"></span>

<p>也就是说，是用Itr去遍历的，这个Itr是ArrayList实现的一个遍历接口、内部类。</p>
<p>但是我在删除的时候是通过ArrayList的remove方法去操作的，不是Itr内部的那个删除方法去操作的。</p>
<p>那么问题就来了：</p>
<p>ArrayList的remove方法修改的变量是继承自AbstractList的变量modCount；而Itr的remove方法修改的是自身的变量expectedModCount。这两个变量的作用都是记录修改次数的。</p>
<p>所以，在用ArrayList的remove方法进行删除操作以后，Itr里面的expectedModCount会与ArrayList的modCount进行比较，二者不相等，所以会抛错。</p>
<p><img src="https://img-blog.csdnimg.cn/111081d940d648c3b2156c4cb037dd6b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeTR1bmc=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="img"></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>解决的方法是改成索引遍历,但是需要在删除之后保证索引的正常:</p>
]]></content>
      <categories>
        <category>异常</category>
      </categories>
      <tags>
        <tag>异常</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>用两个栈实现队列</title>
    <url>/2022/05/21/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h5 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h5><p><em><img src="/2022/05/21/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/image-20220521101300544.png" class title="examplename"></em></p>
<h5 id="题意："><a href="#题意：" class="headerlink" title="题意："></a><strong>题意：</strong></h5><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line"></span><br><span class="line">[<span class="string">&quot;CQueue&quot;</span>,<span class="string">&quot;appendTail&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>] </span><br><span class="line">这一行表示每一行代码的操作</span><br><span class="line"></span><br><span class="line">[[],[<span class="number">3</span>],[],[]]</span><br><span class="line">这个表示每一行代码操作所需要的参数</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line"><span class="symbol">CQueue</span> 表示新建一个<span class="symbol">CQueue</span>对象，对应的所需参数为[]，即此操作不需要参数。</span><br><span class="line">appendTail 表示执行一个appendTail()操作，对应要被操作的元素为<span class="number">3</span>。</span><br><span class="line">deleteHead 表示执行一个deleteHead操作，对应的所需参数为[]，即此操作不需要参数。</span><br><span class="line">deleteHead 表示执行一个deleteHead操作，对应的所需参数为[]，即此操作不需要参数。</span><br><span class="line"></span><br><span class="line">以上的输入其实是一个代码执行的步骤描述与其对应所需参数。</span><br><span class="line"></span><br><span class="line">即两个纬度：</span><br><span class="line"><span class="number">1</span>、操作描述</span><br><span class="line"><span class="number">2</span>、此次操作所需参数</span><br><span class="line"><span class="number">3</span>、操作描述与操作所需参数是通过默认顺序一一对应的。</span><br></pre></td></tr></table></figure>

<h5 id="题解："><a href="#题解：" class="headerlink" title="题解："></a><strong>题解：</strong></h5><p><strong>1、方法一：使用普通的Stack对象实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; stack1;</span><br><span class="line">	LinkedList&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">		stack1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">		stack2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">		stack1.add(value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (stack1.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">				stack2.add(stack1.pop());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> stack2.pop();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">return</span> stack2.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、方法二：使用LinkedList双向链表来实现</strong>（优解）</p>
<p>​		如果你使用Stack的方式来做这道题，会造成速度较慢； 原因的话是Stack继承了Vector接口，而Vector底层是一个Object[]数组，那么就要考虑空间扩容和移位的问题了。 可以使用LinkedList来做Stack的容器，因为LinkedList实现了Deque接口，所以Stack能做的事LinkedList都能做，其本身结构是个双向链表，扩容消耗少。 但是我的意思不是像100%代码那样直接使用一个LinkedList当做队列，那确实是快，但是不符题意。 贴上代码，这样的优化之后，效率提高了40%，超过97%。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line">    <span class="type">Stack</span> <span class="variable">stack1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Stack</span> <span class="variable">stack2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (stack1.empty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">                stack2.add(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>)stack2.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>)stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
        <category>栈与队列</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>剑指offer</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>从尾到头打印链表</title>
    <url>/2022/05/21/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/21/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/image-20220521104152321.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、方法一：使用辅助栈实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; stack = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!(head == <span class="literal">null</span>))&#123;</span><br><span class="line">            stack.push(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[stack.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">                a[i] = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：使用递归实现</strong>（从后往前将链表中的数据放入list里）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        recur(head);</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[tmp.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = tmp.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">recur</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        recur(head.next);</span><br><span class="line">        tmp.add(head.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>剑指offer</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>包含min函数的栈</title>
    <url>/2022/05/21/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/21/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/image-20220521102533380.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、解法一：最笨方法，遍历栈实现</strong>（时间复杂度O(n)）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack.empty())&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> (<span class="type">int</span>) stack.peek();</span><br><span class="line">        <span class="keyword">return</span> peek;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack.empty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">for</span> (Integer x : stack) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x &lt; min) &#123;</span><br><span class="line">                    min = x;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、解法二：多加一个栈，时间复杂度从O(n)变到O(1)</strong> （优解）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1= <span class="literal">null</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">        <span class="keyword">if</span> (stack2.empty() || stack2.peek() &gt;= x) &#123;</span><br><span class="line">            stack2.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack1.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (stack1.peek().equals(stack2.peek()))&#123;</span><br><span class="line">                stack2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stack1.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> (<span class="type">int</span>) stack1.peek();</span><br><span class="line">        <span class="keyword">return</span> peek;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack1.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> stack2.peek();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
        <category>栈与队列</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>剑指offer</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521104938106.png" class title="examplename"></em></p>
<h4 id="解题："><a href="#解题：" class="headerlink" title="解题："></a>解题：</h4><p><strong>1、时间复杂度为O(n)的复杂方法</strong></p>
<ul>
<li><p>使用栈切换顺序，然后存入另一个ListNode，输出</p>
<ul>
<li>&#96;&#96;&#96;java<br>class Solution {<br>public ListNode head1;<br>public ListNode reverseList(ListNode head) {<br>    LinkedList<Integer> stack &#x3D; null;<br>        stack &#x3D; new LinkedList<Integer>();<br>        while (!(head &#x3D;&#x3D; null)) {<br>            stack.push(head.val);<br>            head &#x3D; head.next;<br>        }<br>    int size &#x3D; stack.size();<br>    for (int i &#x3D; 0; i &lt; size; i++) {<br>            ListNode node &#x3D; new ListNode(stack.pop());<br><br>            if (this.head1 &#x3D;&#x3D; null) {<br>                this.head1 &#x3D; node;<br>            } else {<br>                ListNode cur &#x3D; this.head1;<br>                while (cur.next !&#x3D; null) {<br>                    cur &#x3D; cur.next;<br>                }<br>                cur.next &#x3D; node;<br>            }<br>        }<br>        return this.head1;<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 使用递归实现,然后存入另一个ListNode，输出</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    class Solution2 &#123;</span><br><span class="line">    </span><br><span class="line">        ArrayList&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();</span><br><span class="line">        public ListNode head1;</span><br><span class="line">        public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">            recur(head);</span><br><span class="line">    </span><br><span class="line">            for (int i = 0; i &lt; tmp.size(); i++) &#123;</span><br><span class="line">                ListNode node = new ListNode(tmp.get(i));</span><br><span class="line">    </span><br><span class="line">                if (this.head1 == null) &#123;</span><br><span class="line">                    this.head1 = node;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    ListNode cur = this.head1;</span><br><span class="line">                    while (cur.next != null) &#123;</span><br><span class="line">                        cur = cur.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur.next = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.head1;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        void recur(ListNode head) &#123;</span><br><span class="line">            if (head == null) return;</span><br><span class="line">            recur(head.next);</span><br><span class="line">            tmp.add(head.val);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></Integer></Integer></li>
</ul>
</li>
</ul>
<p><strong>2、时间复杂度为O(n)的优化解法</strong></p>
<ul>
<li><p>使用迭代（双指针）</p>
<ul>
<li><p><strong>时间复杂度 O(N) ：</strong> 遍历链表使用线性大小时间。</p>
</li>
<li><p><strong>空间复杂度 O(1) ：</strong> 变量 <code>pre</code> 和 <code>cur</code> 使用常数大小额外空间。</p>
</li>
<li><p>解题思路：</p>
<ul>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105437651.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105456441.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105509583.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105524848.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105531721.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105538707.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105545101.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105551927.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105558024.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105604074.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105610816.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105616249.png" class title="examplename"></em></li>
</ul>
</li>
<li><p>代码：</p>
<ul>
<li><p>&#96;&#96;&#96;java<br>class Solution3 {</p>
<pre><code>public ListNode reverseList(ListNode head) &#123;
    ListNode prev = null;
    ListNode cur = head;
    while(cur != null) &#123;
        ListNode nextNode = cur.next;
        cur.next = prev;
        prev = cur;
        cur = nextNode;
    &#125;
    return prev;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 使用递归，时间复杂度O(n)</span><br><span class="line"></span><br><span class="line">  - 时间复杂度：O(n)O(n)，其中 nn 是链表的长度。需要对链表的每个节点进行反转操作。</span><br><span class="line"></span><br><span class="line">  - 空间复杂度：O(n)O(n)，其中 nn 是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 nn层。</span><br><span class="line"></span><br><span class="line">  - 解题思路：</span><br><span class="line"></span><br><span class="line">    - &#123;%asset_img image-20220521110806821.png examplename%&#125;</span><br><span class="line"></span><br><span class="line">  - 代码：</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    class Solution4 &#123;</span><br><span class="line">        public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">    </span><br><span class="line">            if (head == null || head.next == null) &#123;</span><br><span class="line">                return head;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            ListNode newHead = reverseList(head.next);</span><br><span class="line">            head.next.next = head;</span><br><span class="line">            head.next = null;</span><br><span class="line">            return newHead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>剑指offer</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂链表的复制</title>
    <url>/2022/05/21/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/21/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/image-20220521182707888.png" class title="examplename"></em></p>
<p><em><img src="/2022/05/21/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/image-20220521182758490.png" class title="examplename"></em></p>
<p><em><img src="/2022/05/21/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/image-20220521182825269.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>​		本题中因为随机指针的存在，当我们拷贝节点时，「当前节点的随机指针指向的节点」可能还没创建，因此我们需要变换思路。</p>
<p><strong>1、回溯 + 哈希表</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li>一个可行方案是，我们利用回溯的方式，让每个节点的拷贝操作相互独立。对于当前节点，我们首先要进行拷贝，然后我们进行「当前节点的后继节点」和「当前节点的随机指针指向的节点」拷贝，拷贝完成后将创建的新节点的指针返回，即可完成当前节点的两指针的赋值。</li>
</ul>
</li>
<li><p><strong>时间复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n)，其中 n 是链表的长度。对于每个节点，我们至多访问其「后继节点」和「随机指针指向的节点」各一次，均摊每个点至多被访问两次。</li>
<li><strong>空间复杂度：</strong>O(n)，其中 n 是链表的长度。为哈希表的空间开销。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<ul>
<li>&#96;&#96;&#96;java<br>&#x2F;&#x2F; 回溯 + 哈希表<br>class Solution2 {<br>Map&lt;Node, Node&gt; cachedNode &#x3D; new HashMap&lt;Node, Node&gt;();<br><br>public Node copyRandomList(Node head) {<br>    if (head &#x3D;&#x3D; null) {<br>        return null;<br>    }<br>    if (!cachedNode.containsKey(head)) {<br>        Node headNew &#x3D; new Node(head.val);<br>        cachedNode.put(head, headNew);<br>        headNew.next &#x3D; copyRandomList(head.next);<br>        headNew.random &#x3D; copyRandomList(head.random);<br>    }<br>    return cachedNode.get(head);<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**2、迭代 + 节点拆分**（方法很nice）</span><br><span class="line"></span><br><span class="line">- **解题思路：**</span><br><span class="line"></span><br><span class="line">  - *&#123;%asset_img image-20220521183343757.png examplename%&#125;*</span><br><span class="line">  - ![·](https://assets.leetcode-cn.com/solution-static/jianzhi_35/1.png)</span><br><span class="line">  - ![img](https://assets.leetcode-cn.com/solution-static/jianzhi_35/2.png)</span><br><span class="line">  - ![img](https://assets.leetcode-cn.com/solution-static/jianzhi_35/3.png)</span><br><span class="line">  - ![img](https://assets.leetcode-cn.com/solution-static/jianzhi_35/4.png)</span><br><span class="line"></span><br><span class="line">- **复杂度分析：**</span><br><span class="line"></span><br><span class="line">  - 时间复杂度：O(n)，其中 n 是链表的长度。我们只需要遍历该链表三次。</span><br><span class="line">  - 空间复杂度：O(1)。注意返回值不计入空间复杂度</span><br><span class="line"></span><br><span class="line">- **代码：**</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    class Solution &#123;</span><br><span class="line">        public Node copyRandomList(Node head) &#123;</span><br><span class="line">            if (head == null) &#123;</span><br><span class="line">                return head;</span><br><span class="line">            &#125;</span><br><span class="line">            // 完成链表节点的复制</span><br><span class="line">            for (Node cur = head; cur != null; cur = cur.next.next) &#123;</span><br><span class="line">                Node newNode = new Node(cur.val);</span><br><span class="line">                newNode.next = cur.next;</span><br><span class="line">                cur.next = newNode;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            // 完成链表复制节点的随机指针复制</span><br><span class="line">            for (Node cur = head;cur != null; cur = cur.next.next) &#123;</span><br><span class="line">                Node newNode = cur.next;</span><br><span class="line">                newNode.random = (cur.random != null)?cur.random.next:null; // cur.random为空，空节点不能.next，否则会报错</span><br><span class="line">            &#125;</span><br><span class="line">            Node headNew = head.next;</span><br><span class="line">            // 将链表一分为二</span><br><span class="line">            for (Node cur = head; cur != null; cur = cur.next) &#123;</span><br><span class="line">                Node newNode = cur.next;</span><br><span class="line">                cur.next = newNode.next;</span><br><span class="line">                newNode.next = (cur.next != null)? cur.next.next:null; // 这里判断同理</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            return headNew;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>剑指offer</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>替换空格</title>
    <url>/2022/05/21/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/21/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/image-20220521190640793.png" class title="examplename"></em></p>
<h4 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h4><p><strong>1、调用代码库</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        s = s.replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、字符数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 每次替换从 1 个字符变成 3 个字符，所以需要3倍的大小</span></span><br><span class="line">        <span class="type">char</span>[] array = <span class="keyword">new</span> <span class="title class_">char</span>[s.length() * <span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() ; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                array[size++] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                array[size++] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                array[size++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> array[size++] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array, <span class="number">0</span>, size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂性分析</strong></p>
<ul>
<li>时间复杂度：O(n)<em>O</em>(<em>n</em>)。遍历字符串 <code>s</code> 一遍。</li>
<li>空间复杂度：O(n)<em>O</em>(<em>n</em>)。额外创建字符数组，长度为 <code>s</code> 的长度的 3 倍。</li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>剑指offer</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
