<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>No primary or default constructor found for interface java.util.List原因和解决方法</title>
    <url>/2022/04/24/No%20primary%20or%20default%20constructor%20found%20for%20interface%20java.util.List%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>是list是接口，没有<strong>构造函数</strong></p>
<span id="more"></span>

<p><strong>解决方法：</strong></p>
<ul>
<li>换成ArrayList就可以，</li>
<li>将List转为Json字符串（JSON.toJSONString(list)），或者加入@RequestBody注解</li>
<li>目标对象不匹配，用＠RequestParam让他强制匹配</li>
</ul>
]]></content>
      <categories>
        <category>异常</category>
      </categories>
      <tags>
        <tag>异常</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>0～n-1中缺失的数字</title>
    <url>/2022/05/22/0%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/22/0%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/image-20220522212717368.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、普通遍历：</strong></p>
<ul>
<li><p><strong>思路一：</strong>正常是后一个比前一个大一，找不正常的</p>
<ul>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历求解，思路是正常是后一个比前一个大一，找不正常的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == nums.length -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">return</span> nums[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i != nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i+<span class="number">1</span>] == nums[i] + <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果为空返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>思路二：</strong>正常是数组下标位置对应数组的值，找不正常的</p>
<ul>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]!=i) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是前面是连续的，后面没有东西，则得返回长度;</span></span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>时间复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n)</li>
<li><strong>空间复杂度：</strong>O(1)</li>
</ul>
</li>
</ul>
<p><strong>2、二分法实现</strong></p>
<ul>
<li><p><strong>思路：</strong>划分为俩个组，一个是正常的组，一个比自身位置大于1的组，最后left&gt;right,输出。</p>
<ul>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分法实现，思路就是划分为俩个组，一个是正常的组，一个比自身位置大于1的组，最后left&gt;right,输出</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; mid) &#123;</span><br><span class="line">                right = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>时间复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(logn)</li>
<li><strong>空间复杂度：</strong>O(1)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>查找算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>java.util.concurrentmodificationexception异常原因和解决方法</title>
    <url>/2022/04/24/java.util.concurrentmodificationexception%E5%BC%82%E5%B8%B8%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>简单地说下原因，在我那个项目的代码中，遍历的方式是增强 for 循环，在底层使用的也是迭代器。</p>
<span id="more"></span>

<p>也就是说，是用Itr去遍历的，这个Itr是ArrayList实现的一个遍历接口、内部类。</p>
<p>但是我在删除的时候是通过ArrayList的remove方法去操作的，不是Itr内部的那个删除方法去操作的。</p>
<p>那么问题就来了：</p>
<p>ArrayList的remove方法修改的变量是继承自AbstractList的变量modCount；而Itr的remove方法修改的是自身的变量expectedModCount。这两个变量的作用都是记录修改次数的。</p>
<p>所以，在用ArrayList的remove方法进行删除操作以后，Itr里面的expectedModCount会与ArrayList的modCount进行比较，二者不相等，所以会抛错。</p>
<p><img src="https://img-blog.csdnimg.cn/111081d940d648c3b2156c4cb037dd6b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeTR1bmc=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="img"></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>解决的方法是改成索引遍历,但是需要在删除之后保证索引的正常:</p>
]]></content>
      <categories>
        <category>异常</category>
      </categories>
      <tags>
        <tag>异常</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>包含min函数的栈</title>
    <url>/2022/05/21/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/21/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/image-20220521102533380.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、解法一：最笨方法，遍历栈实现</strong>（时间复杂度O(n)）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack.empty())&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> (<span class="type">int</span>) stack.peek();</span><br><span class="line">        <span class="keyword">return</span> peek;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack.empty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">for</span> (Integer x : stack) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x &lt; min) &#123;</span><br><span class="line">                    min = x;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、解法二：多加一个栈，时间复杂度从O(n)变到O(1)</strong> （优解）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1= <span class="literal">null</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">        <span class="keyword">if</span> (stack2.empty() || stack2.peek() &gt;= x) &#123;</span><br><span class="line">            stack2.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack1.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (stack1.peek().equals(stack2.peek()))&#123;</span><br><span class="line">                stack2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stack1.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> (<span class="type">int</span>) stack1.peek();</span><br><span class="line">        <span class="keyword">return</span> peek;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack1.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> stack2.peek();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
        <category>栈与队列</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二维数组中的查找</title>
    <url>/2022/05/23/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/23/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/image-20220523112001365.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、二分查找</strong></p>
<ul>
<li><p><strong>解题思路：</strong>将每一行进行二分查找。</p>
</li>
<li><p><strong>时间复杂度分析：</strong></p>
<ul>
<li>时间复杂度O(mlogn)，m为行数，n为列数</li>
<li>空间复杂度O(1)</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分查找时间复杂度O(mlogn)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取行数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="comment">// 获取列数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; col; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">Left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 一行的长度matrix[0].length(有几列)</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">Right</span> <span class="operator">=</span> row - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (Left &lt; Right ) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> Left + (Right - Left) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (target &gt; matrix[i][mid]) &#123;</span><br><span class="line">                    Left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (target &lt; matrix[i][mid]) &#123;</span><br><span class="line">                    Right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">if</span> (Left == Right) &#123;</span><br><span class="line">                System.out.println(matrix[i][Right]);</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][Right] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、标志数法</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li><p>“根节点” 对应的是矩阵的 “左下角” 和 “右上角” 元素，本文称之为 标志数 ，以 matrix 中的 左下角元素 为标志数 flag ，则有:	</p>
<ul>
<li>若 flag &gt; target ，则 target 一定在 flag 所在 行的上方 ，即 flag 所在行可被消去。</li>
<li>若 flag &lt; target ，则 target 一定在 flag 所在 列的右方 ，即 flag 所在列可被消去。</li>
</ul>
</li>
<li><p><em><img src="/2022/05/23/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/image-20220523112822109.png" class title="examplename"></em></p>
</li>
</ul>
</li>
<li><p><strong>时间复杂度分析：</strong></p>
<ul>
<li>时间复杂度O(m+n)，m为行数，n为列数</li>
<li>空间复杂度O(1)</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标志数法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &gt; matrix[i][j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (target &lt; matrix[i][j]) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (target == matrix[i][j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>查找算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>从尾到头打印链表</title>
    <url>/2022/05/21/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/21/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/image-20220521104152321.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、方法一：使用辅助栈实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; stack = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!(head == <span class="literal">null</span>))&#123;</span><br><span class="line">            stack.push(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[stack.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">                a[i] = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：使用递归实现</strong>（从后往前将链表中的数据放入list里）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        recur(head);</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[tmp.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = tmp.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">recur</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        recur(head.next);</span><br><span class="line">        tmp.add(head.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521104938106.png" class title="examplename"></em></p>
<h4 id="解题："><a href="#解题：" class="headerlink" title="解题："></a>解题：</h4><p><strong>1、时间复杂度为O(n)的复杂方法</strong></p>
<ul>
<li><p>使用栈切换顺序，然后存入另一个ListNode，输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode head1;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="literal">null</span>;</span><br><span class="line">            stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">while</span> (!(head == <span class="literal">null</span>)) &#123;</span><br><span class="line">                stack.push(head.val);</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stack.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(stack.pop());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.head1 == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.head1 = node;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>.head1;</span><br><span class="line">                    <span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                        cur = cur.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur.next = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.head1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用递归实现,然后存入另一个ListNode，输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> ListNode head1;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        recur(head);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tmp.size(); i++) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(tmp.get(i));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.head1 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.head1 = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>.head1;</span><br><span class="line">                <span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                    cur = cur.next;</span><br><span class="line">                &#125;</span><br><span class="line">                cur.next = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.head1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">recur</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        recur(head.next);</span><br><span class="line">        tmp.add(head.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、时间复杂度为O(n)的优化解法</strong></p>
<ul>
<li><p>使用迭代（双指针）</p>
<ul>
<li><p><strong>时间复杂度 O(N) ：</strong> 遍历链表使用线性大小时间。</p>
</li>
<li><p><strong>空间复杂度 O(1) ：</strong> 变量 <code>pre</code> 和 <code>cur</code> 使用常数大小额外空间。</p>
</li>
<li><p>解题思路：</p>
<ul>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105437651.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105456441.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105509583.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105524848.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105531721.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105538707.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105545101.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105551927.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105558024.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105604074.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105610816.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521105616249.png" class title="examplename"></em></li>
</ul>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">nextNode</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用递归，时间复杂度O(n)</p>
<ul>
<li><p>时间复杂度：O(n)O(n)，其中 nn 是链表的长度。需要对链表的每个节点进行反转操作。</p>
</li>
<li><p>空间复杂度：O(n)O(n)，其中 nn 是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 nn层。</p>
</li>
<li><p>解题思路：</p>
<ul>
<li><img src="/2022/05/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220521110806821.png" class title="examplename"></li>
</ul>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>在排序数组中查找数字1</title>
    <url>/2022/05/22/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%971/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>*<img src="/2022/05/22/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%971/image-20220522200203070.png" class title="examplename"></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、二分法</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li>使用二分法分别找到 左边界 left和 右边界 right ，易得数字 target 的数量为right−left−1 。</li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(log N)：</strong> 二分法为对数级别复杂度。</li>
<li><strong>空间复杂度 O(1)：</strong> 几个变量使用常数大小的额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">firstPosition</span> <span class="operator">=</span> findFirstPosition(nums,target);</span><br><span class="line">        <span class="keyword">if</span> (firstPosition == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastPosition</span> <span class="operator">=</span> findLastPosition(nums,target);</span><br><span class="line">        <span class="keyword">return</span> lastPosition - firstPosition + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找target第一次出现的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findFirstPosition</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &gt; left)&#123;</span><br><span class="line">            <span class="comment">// 这样写避免left+right在值很大的时候整型溢出</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                <span class="comment">// [mid+1 ... right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// [left ... mid]</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[left] == target) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找target最后一次出现的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findLastPosition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &gt; left)&#123;</span><br><span class="line">            <span class="comment">// 这样写避免left+right在值很大的时候整型溢出</span></span><br><span class="line">            <span class="comment">// 将mid赋值给left的时候要向上取整，不然left可能永远小于right，也就永远跳不出循环</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">                <span class="comment">// [mid ... right]</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// [left ... mid-1]</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为int firstPosition = findFirstPosition(nums,target);已经找到target了，所以必有target，直接返回left即可。</span></span><br><span class="line">        <span class="comment">//if (nums[left] == target) &#123;</span></span><br><span class="line">        <span class="comment">//    System.out.println(left);</span></span><br><span class="line">        <span class="comment">//    return left;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//return -1;</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//@Test</span></span><br><span class="line">    <span class="comment">//void test() &#123;</span></span><br><span class="line">    <span class="comment">//        int[] nums = &#123;5,7,7,8,8,10&#125;;</span></span><br><span class="line">    <span class="comment">//    int search = this.search(nums, 8);</span></span><br><span class="line">    <span class="comment">//    System.out.println(search);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>查找算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>左旋转字符串</title>
    <url>/2022/05/21/%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/21/%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20220521201003026.png" class title="examplename"></em></p>
<h4 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、字符串切片</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> s.substring(<span class="number">0</span>, n);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.substring(n,s.length());</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s2 + s1;</span><br><span class="line">        <span class="keyword">return</span> s3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、列表遍历拼接</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &lt; s.length(); i++) &#123;</span><br><span class="line">            s3.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            s3.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s3.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、字符串遍历拼接</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &lt; s.length(); i++) &#123;</span><br><span class="line">            s3 += s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            s3 += s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂链表的复制</title>
    <url>/2022/05/21/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/21/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/image-20220521182707888.png" class title="examplename"></em></p>
<p><em><img src="/2022/05/21/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/image-20220521182758490.png" class title="examplename"></em></p>
<p><em><img src="/2022/05/21/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/image-20220521182825269.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>​		本题中因为随机指针的存在，当我们拷贝节点时，「当前节点的随机指针指向的节点」可能还没创建，因此我们需要变换思路。</p>
<p><strong>1、回溯 + 哈希表</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li>一个可行方案是，我们利用回溯的方式，让每个节点的拷贝操作相互独立。对于当前节点，我们首先要进行拷贝，然后我们进行「当前节点的后继节点」和「当前节点的随机指针指向的节点」拷贝，拷贝完成后将创建的新节点的指针返回，即可完成当前节点的两指针的赋值。</li>
</ul>
</li>
<li><p><strong>时间复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n)，其中 n 是链表的长度。对于每个节点，我们至多访问其「后继节点」和「随机指针指向的节点」各一次，均摊每个点至多被访问两次。</li>
<li><strong>空间复杂度：</strong>O(n)，其中 n 是链表的长度。为哈希表的空间开销。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回溯 + 哈希表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    Map&lt;Node, Node&gt; cachedNode = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node, Node&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!cachedNode.containsKey(head)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">headNew</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(head.val);</span><br><span class="line">            cachedNode.put(head, headNew);</span><br><span class="line">            headNew.next = copyRandomList(head.next);</span><br><span class="line">            headNew.random = copyRandomList(head.random);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cachedNode.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、迭代 + 节点拆分</strong>（方法很nice）</p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li><em><img src="/2022/05/21/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/image-20220521183343757.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/image-20220521191723967.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/image-20220521191905643.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/image-20220521191958997.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/21/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/image-20220521192018933.png" class title="examplename"></em></li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 是链表的长度。我们只需要遍历该链表三次。</li>
<li>空间复杂度：O(1)。注意返回值不计入空间复杂度</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完成链表节点的复制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head; cur != <span class="literal">null</span>; cur = cur.next.next) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val);</span><br><span class="line">            newNode.next = cur.next;</span><br><span class="line">            cur.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完成链表复制节点的随机指针复制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;cur != <span class="literal">null</span>; cur = cur.next.next) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            newNode.random = (cur.random != <span class="literal">null</span>)?cur.random.next:<span class="literal">null</span>; <span class="comment">// cur.random为空，空节点不能.next，否则会报错</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">headNew</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">// 将链表一分为二</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head; cur != <span class="literal">null</span>; cur = cur.next) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = newNode.next;</span><br><span class="line">            newNode.next = (cur.next != <span class="literal">null</span>)? cur.next.next:<span class="literal">null</span>; <span class="comment">// 这里判断同理</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> headNew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>应战秋招总结</title>
    <url>/2022/04/21/%E5%BA%94%E6%88%98%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="1、何为秋招？"><a href="#1、何为秋招？" class="headerlink" title="1、何为秋招？"></a>1、何为秋招？</h2><h3 id="1-1、应届生"><a href="#1-1、应届生" class="headerlink" title="1.1、应届生"></a>1.1、应届生</h3><p>暑假：大学生（实习、工作）</p>
<span id="more"></span>

<p>8月、春招！</p>
<p>应届毕业生！</p>
<p>2015年级 2019界 2016年级 2020界</p>
<p>应届毕业生： 大三升大四！</p>
<p><strong>大三暑假找工作找实习！</strong></p>
<p>大四：毕业再找！切记、不好！</p>
<p>2020校招！不收2019届！</p>
<h3 id="1-2、秋招-x2F-春招-x2F-校招"><a href="#1-2、秋招-x2F-春招-x2F-校招" class="headerlink" title="1.2、秋招&#x2F;春招&#x2F;校招"></a>1.2、秋招&#x2F;春招&#x2F;校招</h3><p>校招： 校园招聘</p>
<p>流程：网申-笔试-面试（23轮）-录取通知-体检-签三方-毕业！-上班！ 秋招： 7来年一月 7~10，校招核心！</p>
<p>秋招名额远大于春招！</p>
<p>招聘信息 宣讲会 招聘会</p>
<p>春招： 春节到6月 3~4、秋招补录！</p>
<blockquote>
<p>网申（不打无准备的仗）</p>
</blockquote>
<p>网络在线申请，大型企业！</p>
<p>注意：填表格！</p>
<p>开放性问题：优缺点？失败经历？公司的看法？</p>
<p>一定要仔细？大三时候就一定要准备好！</p>
<p>复制到记事本！</p>
<blockquote>
<p>宣讲会</p>
</blockquote>
<p>公司 HR、技术！ 讲解公司的内容、岗位、待遇、Q&amp;A？</p>
<p>1、开完就走！</p>
<p>2、现场接受简历</p>
<p>3、现场接受简历、面试！一分钟（记住你！ 准备60s的自我介绍）</p>
<p>4、现场接受简历、面试、笔试！</p>
<p><strong>多跑!</strong></p>
<blockquote>
<p>招聘会（多对一）体验一次！</p>
</blockquote>
<p>政府: 人力资源组织 ! 现场招聘&#x2F;网络招聘</p>
<p><strong>现场招聘</strong></p>
<p>综合&#x2F;理工科&#x2F;经管文科</p>
<p><strong>准备：</strong></p>
<p>HR、直接递交简历。现场面试， hR！</p>
<p>1、简历！</p>
<p>2、带上U盘！资料文件！防备不时之需</p>
<p>3、目标确定性： 1000家公司（2~3 公司的信息、岗位需要的职业技能！） 简历是可以改变的！（掌握技能、实习工作经历） 3个公司、3份不一样的（根据公司的需要来定 制！）</p>
<h3 id="1-3、社招-x2F-海投"><a href="#1-3、社招-x2F-海投" class="headerlink" title="1.3、社招&#x2F;海投"></a>1.3、社招&#x2F;海投</h3><blockquote>
<p>社招： 社会招聘！ 目标人群： 毕业的人、经验人士！</p>
</blockquote>
<p>社招持续存在！</p>
<p>社招: 校招是有新人培训！社招直接进去就工作！ 一定都是招收有经验的人士！</p>
<p>参加校招：大四！不要在毕业之后！</p>
<p>大三~大四！重视校招！</p>
<p>社招: 猎头、打造知名度（开源项目、博客、媒体影响力！）</p>
<blockquote>
<p>海投: 广撒网！</p>
</blockquote>
<p>不建议：没有针对！</p>
<p>百度、阿里：做了准备、历届面试题、实训！</p>
<p>投的数量多不一定有用！</p>
<p>不打无准备的仗： 秋招、社招（选定心仪的公司！ 2~3）</p>
<p>1、集中精力研究这些公司的面试！</p>
<p>2、努力提升自己的技能！拿到再多的oﬀer ，最终你只能选择一家！ 面试！一开始就选择了！</p>
<p>100家公司！ 没有人鸟你，自我否定！</p>
<h2 id="2、秋招信息如何获取？"><a href="#2、秋招信息如何获取？" class="headerlink" title="2、秋招信息如何获取？"></a>2、秋招信息如何获取？</h2><p>秋招：获取秋招信息</p>
<p>1、公司官网+官方招聘公众号！正规</p>
<p>2、内推（熟人内部推荐！群里&#x2F;公众号）学长、学姐</p>
<p>3、牛客网！专业的网站去找咨询！</p>
<p>牛客求职区：<a href="https://www.nowcoder.com/recommend">https://www.nowcoder.com/recommend</a></p>
<p>牛客讨论区：<a href="https://www.nowcoder.com/discuss">https://www.nowcoder.com/discuss</a></p>
<p>校招日程汇总：<a href="https://www.nowcoder.com/school/schedule">https://www.nowcoder.com/school/schedule</a></p>
<p>大数据：筛选出有用的消息！</p>
<p>不要超过5家公司！</p>
<p>百度、阿里、腾讯、美团、京东</p>
<p><strong>到社会上第一步: 选择</strong></p>
<p>1、钱多事少离家近 （钱多）</p>
<p>2、背书，大公司！ 证明！</p>
<p>3、锻炼自己！<br>工资 、能力对等！</p>
<h2 id="3、如何备战秋招？"><a href="#3、如何备战秋招？" class="headerlink" title="3、如何备战秋招？"></a>3、如何备战秋招？</h2><h3 id="3-1、简历（ps做简历）"><a href="#3-1、简历（ps做简历）" class="headerlink" title="3.1、简历（ps做简历）"></a>3.1、简历（ps做简历）</h3><p><strong>1、模板！</strong></p>
<ul>
<li>word 黑白字！</li>
<li>一定要找一个稳健的模板（工作相关的模板）</li>
<li>尽量不要太多（最多2~3张&#x2F; 1张能解决是最好的）</li>
<li>突出主题（线上发邮件：PDF！不要发word、文字乱码！）</li>
<li>颜值高、照片！（大学都去拍摄一组正装的艺术照！）</li>
<li>不同的公司岗位你要写不同的简历！</li>
<li>内容：<ul>
<li>个人信息： 姓名、求职岗位、手机号、邮箱地址（突出显示、一下子就能看到自己的联系方式）</li>
<li>学校的学历： 毕业院校、本科：直接写本科院校：研究生：本科毕业院校、研究生毕业院校。有的公司敲门砖就是 985&#x2F;211<ul>
<li>问题：我的学校不够好？ 学校不是最致命的条件、毕业院校不是很好（重点就是 实习经历+项目经历</li>
</ul>
</li>
<li>博客&#x2F;影响力的东西：一定要突出！（价值） 学习一定要产出！</li>
<li>实习经历：（重中之重）<ul>
<li>大厂实习经历！最好的！</li>
<li>假设没有实习经历。 突出项目经历！</li>
<li>项目经历： 自己在学校做过哪些项目 真实，自己做过哪些项目经历</li>
<li>切记不要流水账！<ul>
<li>我做了什么项目</li>
<li>我在项目中负责那一部分</li>
<li>在项目开发中遇到了哪些难题 我是怎么处理和解决的！</li>
</ul>
</li>
<li>不要伪造（培训机构出来的人，大部分都会伪造项目经历和工作年龄！）</li>
</ul>
</li>
</ul>
</li>
<li>校园经历：<ul>
<li>学生会、社团。自己在学校举办的活动。</li>
<li>获奖经历。</li>
<li>奖学金</li>
</ul>
</li>
<li>掌握的技能<ul>
<li>如实的写</li>
<li>熟悉、精通（少用精通，最多1~2个精通！）</li>
<li>面试会通过这个来问你！</li>
<li>不要在这里给自己挖坑！</li>
</ul>
</li>
</ul>
<p>2、真实！</p>
<p>3、措辞！</p>
<h3 id="3-2、笔试准备"><a href="#3-2、笔试准备" class="headerlink" title="3.2、笔试准备"></a>3.2、笔试准备</h3><p>技术岗（编程和问答！）</p>
<p>解决方法：看书+练题！多锻炼自己的说话能力！</p>
<p>练题不要瞎练习：针对性练习题目</p>
<p>目标：</p>
<p>找到历届的笔试面试题！ 提前3个月做准备！ 刷题+属性以前的套路！</p>
<ul>
<li><p>名企笔试真题练习：<a href="https://www.nowcoder.com/contestRoom">https://www.nowcoder.com/contestRoom</a></p>
</li>
<li><p>校招笔试真题汇总：<a href="https://www.nowcoder.com/contestRoom?mutiTagIds=1657">https://www.nowcoder.com/contestRoom?mutiTagIds=1657</a></p>
</li>
</ul>
<p>校招备战学习计划：<a href="https://www.nowcoder.com/studypath/1">https://www.nowcoder.com/studypath/1</a></p>
<ul>
<li><p>在线编程：<a href="https://www.nowcoder.com/activity/oj">https://www.nowcoder.com/activity/oj</a></p>
</li>
<li><p>剑指oﬀer在线编程：<a href="https://www.nowcoder.com/ta/coding-interviews">https://www.nowcoder.com/ta/coding-interviews</a></p>
</li>
</ul>
<p>不打无准备的仗！</p>
<p>算法很重要，没有套路，就是多刷题！一定要多花时间研究！</p>
<p>大学生：4年！</p>
<p>大一大二就扎实学习基础技能！</p>
<p>大三了解公司，了解面试，刷题！</p>
<p>大三暑假：找实习找工作</p>
<p>大四就是毕业、交朋友、熟悉公司、到社会！</p>
<h3 id="3-3、面试准备"><a href="#3-3、面试准备" class="headerlink" title="3.3、面试准备"></a>3.3、面试准备</h3><p>多看面经！</p>
<p>每个公司的面试风格都不同！</p>
<ul>
<li><p>牛客讨论区：<a href="https://www.nowcoder.com/discuss">https://www.nowcoder.com/discuss</a></p>
</li>
<li><p>各岗位汇总目录：<a href="https://www.nowcoder.com/discuss/167046">https://www.nowcoder.com/discuss/167046</a></p>
</li>
<li><p>各公司面经汇总目录：<a href="https://www.nowcoder.com/discuss/161635">https://www.nowcoder.com/discuss/161635</a></p>
</li>
</ul>
<p>1、多看他人的面经？</p>
<p>2、善于总结自己的面试经验？多分享（交流）</p>
<p>练手：</p>
<p>中意大公司，面试很紧张！</p>
<p>去小公司面试锻炼：慢慢找到自己的不足，锻炼经验，保证自己面试不经常！</p>
<p>练到自己不紧张不惧怕面试了就可以去自己中意的公司面试！</p>
<p>要把最好的状态留个最重要的面试！</p>
<p>面试：不断地打击自信心的过程！</p>
<p>千万不要对自己失去信心！</p>
<p>最黑暗时刻、就是黎明前！</p>
<p>坚持：多找自己的问题，弥补不足，在尝试！</p>
<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>1、秋招时机，提前批、内推、公众平台、社会招聘、…… 信息很重要！</p>
<p>2、早些做好自己的职业规划（大三之前）</p>
<p>3、写一个优秀的简历。不是自我介绍，而是让公司看到简历之后知道为什么需要你！简历是可以有多 份！</p>
<p>4、笔试和面试尽量提前3个月准备充分！提前了解公司！<br>参考链接：<a href="https://www.bilibili.com/video/BV16C4y1t7Mi%EF%BC%8C%E8%B5%84%E6%BA%90%E6%9D%A5%E8%87%AA**%E7%8B%82%E7%A5%9E%E8%AF%B4**yyds%EF%BC%81">https://www.bilibili.com/video/BV16C4y1t7Mi，资源来自**狂神说**yyds！</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>招聘</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中重复的数字</title>
    <url>/2022/05/22/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/22/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/image-20220522075236430.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、哈希表 &#x2F; Set</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用set.contains方法判断</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:</span><br><span class="line">             nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(num)) &#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;<span class="keyword">else</span> set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用set集合中不能有重复的特性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">repeat</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(num)) &#123;</span><br><span class="line">                repeat = num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> repeat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>复杂度分析：</strong><ul>
<li>**时间复杂度 O(N)**： 遍历数组使用 O(N) ，HashSet 添加与查找元素皆为 O(1)。</li>
<li>**空间复杂度 O(N)**： HashSet 占用 O(N) 大小的额外空间。</li>
</ul>
</li>
</ul>
<p><strong>2、原地交换</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li>可遍历数组并通过交换操作，使元素的 索引 与 值 一一对应（即 nums[i]&#x3D;i ）。因而，就能通过索引映射对应的值，起到与字典等价的作用。</li>
<li><em><img src="/2022/05/22/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/image-20220522080700921.png" class title="examplename"></em></li>
<li>遍历中，第一次遇到数字 x 时，将其交换至索引 x 处；而当第二次遇到数字 x 时，一定有 nums[x]&#x3D;x ，此时即可得到一组重复数字。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原地交换</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums.length)&#123;</span><br><span class="line">            <span class="comment">//  说明此数字已在对应索引位置，无需交换，因此跳过</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == i) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断索引为nums[i]的是否与索引为i的相等，相等说明索引nums[i]已经有与nums[i]的值相等的了，即有重复的了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[nums[i]] == nums[i]) <span class="keyword">return</span> nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i] = nums[tmp];</span><br><span class="line">            nums[tmp] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>复杂度分析</strong>：</p>
<ul>
<li>**时间复杂度 O(N)**： 遍历数组使用 O(N) ，每轮遍历的判断和交换操作使用 O(1)。</li>
<li>**空间复杂度 O(1)**： 使用常数复杂度的额外空间。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>查找算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>用两个栈实现队列</title>
    <url>/2022/05/21/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h5 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h5><p><em><img src="/2022/05/21/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/image-20220521101300544.png" class title="examplename"></em></p>
<h5 id="题意："><a href="#题意：" class="headerlink" title="题意："></a><strong>题意：</strong></h5><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line"></span><br><span class="line">[<span class="string">&quot;CQueue&quot;</span>,<span class="string">&quot;appendTail&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>] </span><br><span class="line">这一行表示每一行代码的操作</span><br><span class="line"></span><br><span class="line">[[],[<span class="number">3</span>],[],[]]</span><br><span class="line">这个表示每一行代码操作所需要的参数</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line"><span class="symbol">CQueue</span> 表示新建一个<span class="symbol">CQueue</span>对象，对应的所需参数为[]，即此操作不需要参数。</span><br><span class="line">appendTail 表示执行一个appendTail()操作，对应要被操作的元素为<span class="number">3</span>。</span><br><span class="line">deleteHead 表示执行一个deleteHead操作，对应的所需参数为[]，即此操作不需要参数。</span><br><span class="line">deleteHead 表示执行一个deleteHead操作，对应的所需参数为[]，即此操作不需要参数。</span><br><span class="line"></span><br><span class="line">以上的输入其实是一个代码执行的步骤描述与其对应所需参数。</span><br><span class="line"></span><br><span class="line">即两个纬度：</span><br><span class="line"><span class="number">1</span>、操作描述</span><br><span class="line"><span class="number">2</span>、此次操作所需参数</span><br><span class="line"><span class="number">3</span>、操作描述与操作所需参数是通过默认顺序一一对应的。</span><br></pre></td></tr></table></figure>

<h5 id="题解："><a href="#题解：" class="headerlink" title="题解："></a><strong>题解：</strong></h5><p><strong>1、方法一：使用普通的Stack对象实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line">    <span class="type">Stack</span> <span class="variable">stack1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Stack</span> <span class="variable">stack2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (stack1.empty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">                stack2.add(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>)stack2.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>)stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、方法二：使用LinkedList双向链表来实现</strong>（优解）</p>
<p>​		如果你使用Stack的方式来做这道题，会造成速度较慢； 原因的话是Stack继承了Vector接口，而Vector底层是一个Object[]数组，那么就要考虑空间扩容和移位的问题了。 可以使用LinkedList来做Stack的容器，因为LinkedList实现了Deque接口，所以Stack能做的事LinkedList都能做，其本身结构是个双向链表，扩容消耗少。 但是我的意思不是像100%代码那样直接使用一个LinkedList当做队列，那确实是快，但是不符题意。 贴上代码，这样的优化之后，效率提高了40%，超过97%。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; stack1;</span><br><span class="line">	LinkedList&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">		stack1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">		stack2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">		stack1.add(value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (stack1.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">				stack2.add(stack1.pop());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> stack2.pop();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">return</span> stack2.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
        <category>栈与队列</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>替换空格</title>
    <url>/2022/05/21/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/21/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/image-20220521190640793.png" class title="examplename"></em></p>
<h4 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h4><p><strong>1、调用代码库</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        s = s.replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、字符数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 每次替换从 1 个字符变成 3 个字符，所以需要3倍的大小</span></span><br><span class="line">        <span class="type">char</span>[] array = <span class="keyword">new</span> <span class="title class_">char</span>[s.length() * <span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() ; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                array[size++] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                array[size++] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                array[size++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> array[size++] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array, <span class="number">0</span>, size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂性分析</strong></p>
<ul>
<li>时间复杂度：O(n)。遍历字符串 <code>s</code> 一遍。</li>
<li>空间复杂度：O(n)。额外创建字符数组，长度为 <code>s</code> 的长度的 3 倍。</li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>认证与授权实现思路</title>
    <url>/2022/04/24/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="认证与授权实现思路"><a href="#认证与授权实现思路" class="headerlink" title="认证与授权实现思路"></a>认证与授权实现思路</h2><p>Spring Security其实就是用<strong>filter</strong>，多请求的路径进行过滤。</p>
<span id="more"></span>

<p>​	如果系统的模块众多，每个模块都需要就行授权与认证，所以我们选择基于token的形式进行授权与认 证，用户根据用户名密码认证成功，然后获取当前用户角色的一系列权限值，并以用户名为key，权限列 表为value的形式存入redis缓存中，根据用户名相关信息生成token返回，浏览器将token记录到cookie中， 每次调用api接口都默认将token携带到header请求头中，Spring-security解析header头获取token信息，解 析token获取当前用户名，根据用户名就可以从redis中获取权限列表，这样Spring-security就能够判断当前 请求是否有权限访问</p>
<p><em><img src="/2022/04/24/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/image-20220424191422878.png" class title="examplename"></em></p>
]]></content>
      <categories>
        <category>面试</category>
        <category>面试题</category>
        <category>权限</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>面试</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转数组的最小数字</title>
    <url>/2022/05/23/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/23/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/image-20220523193220775.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、使用二分法+暴力</strong></p>
<ul>
<li><p><strong>解题思路：</strong>寻找旋转数组的最小元素即为寻找 <strong>右排序数组</strong> 的首个元素 nums[x] ，称 x为 <strong>旋转点</strong> 。</p>
<ul>
<li><em><img src="/2022/05/23/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/image-20220523193434233.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/23/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/image-20220523193527081.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/23/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/image-20220523193553110.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/23/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/image-20220523193607494.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/23/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/image-20220523193631168.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/23/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/image-20220523193645968.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/23/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/image-20220523193706028.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/23/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/image-20220523193721084.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/23/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/image-20220523193737369.png" class title="examplename"></em></li>
<li><em><img src="/2022/05/23/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/image-20220523193753498.png" class title="examplename"></em></li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(log_2 N) ：</strong> 在特例情况下（例如 [1, 1, 1, 1]），会退化到 O(N)。</li>
<li><strong>空间复杂度 O(1)：</strong> i , j , mid 变量使用常数大小的额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分法求解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minArray</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> i + (j-i) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] &lt; numbers[j]) &#123;</span><br><span class="line">                j = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; numbers[j]) &#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>补充思考： 为什么本题二分法不用 nums[mid] 和 nums[i] 作比较？</strong></p>
<p>​	二分目的是判断 mid 在哪个排序数组中，从而缩小区间。而在 nums[m] &gt; nums[i]情况下，无法判断 mid 在哪个排序数组中。本质上是由于 j 初始值肯定在右排序数组中； i 初始值无法确定在哪个排序数组中。举例如下：</p>
<blockquote>
<p>对于以下两示例，当 i &#x3D; 0, j &#x3D; 4, mid &#x3D; 2 时，有 nums[m] &gt; nums[i] ，而结果不同。</p>
<p>[1, 2, 3, 4 ,5] 旋转点 x &#x3D; 0 ： m 在右排序数组（此示例只有右排序数组）； </p>
<p>[3, 4, 5, 1 ,2] 旋转点 x &#x3D; 3 ： m 在左排序数组。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
        <category>查找算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第一个只出现一次的字符</title>
    <url>/2022/05/23/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><em><img src="/2022/05/23/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/image-20220523213750652.png" class title="examplename"></em></p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>1、使用哈希表存储</strong></p>
<ul>
<li><p><strong>解题思路：</strong></p>
<ul>
<li>遍历字符串 <code>s</code> ，使用哈希表统计 “各字符数量是否 &gt;1 ”。</li>
<li>再遍历字符串 <code>s</code> ，在哈希表中找到首个 “数量为 1 的字符”，并返回。</li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> N 为字符串 s 的长度；需遍历 s 两轮，使用 O(N) ；HashMap 查找操作的复杂度为 O(1)；</li>
<li><strong>空间复杂度 O(1) ：</strong> 由于题目指出 s 只包含小写字母，因此最多有 26 个不同字符，HashMap 存储需占用 O(26) &#x3D; O(1) 的额外空间。</li>
</ul>
</li>
<li><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        HashMap&lt;Character, Boolean&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] array = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:</span><br><span class="line">             array) &#123;</span><br><span class="line">            <span class="comment">// 如果遇到重复的，value变为false</span></span><br><span class="line">            map.put(c,!map.containsKey(c));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在map中查找第一个为true的</span></span><br><span class="line">        <span class="comment">// 因为hashMap是乱序的，不能直接通过map查找到第一个，而是通过array原来的顺序，进行map查找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:</span><br><span class="line">             array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(c)) &#123;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、有序哈希表</strong></p>
<p>在字符串长度较大、重复字符很多时，“有序哈希表” 解法理论上效率更高。</p>
<p>解题思路和时间复杂度一样。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有序哈希表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;Character, Boolean&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : sc)</span><br><span class="line">            map.put(c, !map.containsKey(c));</span><br><span class="line">        <span class="comment">// Map的entrySet()方法返回一个实现Map.Entry接口的对象集合。Map.Entry里面包含getKey()和getValue()方法,entrySet实现了Set接口，里面存放的是键值对。一个K对应一个V。</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Character, Boolean&gt; d : map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(d.getValue()) <span class="keyword">return</span> d.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
        <category>查找算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>总结常见的LinkedList队列方法</title>
    <url>/2022/05/24/%E6%80%BB%E7%BB%93%E5%B8%B8%E8%A7%81%E7%9A%84%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<ul>
<li><p>add 增加一个元索 如果队列已满，则抛出一个IIIegaISlabEepeplian异常</p>
</li>
<li><p>remove 移除并返回队列头部的元素 如果队列为空，则抛出一个 NoSuchElementException</p>
</li>
<li><p>element 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常</p>
</li>
<li><p>offer 添加一个元素并返回true 如果队列已满，则返回false</p>
</li>
</ul>
<ul>
<li><p>poll 移除并返问队列头部的元素 如果队列为空，则返回null</p>
</li>
<li><p>peek 返回队列头部的元素 如果队列为空，则返回null</p>
</li>
<li><p>put 添加一个元素 如果队列满，则阻塞</p>
</li>
<li><p>take 移除并返回队列头部的元素 如果队列为空，则阻塞</p>
</li>
</ul>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>队列</tag>
      </tags>
  </entry>
</search>
